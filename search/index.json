[{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [baekjoon / 10757] 9223372036854775807 9223372036854775808 */ const fs = require(\u0026#34;fs\u0026#34;); let input = fs.readFileSync(\u0026#34;./input.txt\u0026#34;).toString(); let result = input.split(\u0026#34; \u0026#34;).filter((num) =\u0026gt; num !== \u0026#34;\u0026#34;); let num1 = parseInt(result[0]); let num2 = parseInt(result[1]); solution(num1, num2); function solution(param1, param2) { console.log(param1 + param2); } 처음엔 쉽게 정답이 될 줄 알았다..\n근데 자꾸 이상한 답이 나오더라?\n음?\u0026hellip;. 뭐야 분명 18446744073709551615이란 값이 나와야하는데 계속 18446744073709552000이 나옴\n아ㅋㅋ\n결국 한개씩 출력해봄 입력도 이상하게 나오는지\n음? ㅋㅋ 이건 또 뭐임\n찾아보니 Javascript에는 BigInt라는 새로운 데이터형이 존재한다는 것을 알았다. BigInt는 Javascript Number의 최대범위인 2^53 - 1보다 큰 정수를 표현할 수 있다고 한다.\nJavascript BigInt\n그래서 parseInt()대신 BigInt()로 바꿔서 출력해봤다.\n1 2 3 4 ... let num1 = BigInt(result[0]); let num2 = BigInt(result[1]); ... 드디어 숫자가 변하지 않고 정확하게 출력되는 것을 볼 수 있다. 근데, 뒤에 n이라는 문자가 같이 표기되어 나온다?\n이건 .toString() 메소드를 쓰면 해결되었다.\n^오^\n다시 두 수의 덧셈을 구하여 출력해보는 걸로 하자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* [baekjoon / 10757] 9223372036854775807 9223372036854775808 */ const fs = require(\u0026#34;fs\u0026#34;); let input = fs.readFileSync(\u0026#34;./input.txt\u0026#34;).toString(); let result = input.split(\u0026#34; \u0026#34;).filter((num) =\u0026gt; num !== \u0026#34;\u0026#34;); let num1 = BigInt(result[0]); let num2 = BigInt(result[1]); solution(num1, num2); function solution(param1, param2) { let result = param1 + param2; console.log(result.toString()); } 해결완료 ✅\n","date":"2023-04-19T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-10757%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-10757%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 10757번 문제"},{"content":"Scaffold란? Flutter에서 Scaffold는 Material Design에서 사용되는 앱의 뼈대(Layout)을 제공하는 위젯입니다.\nScaffold class\n역할 Scaffold는 앱의 기본적인 레이아웃 구조를 정의하고, appbar, toolbar, drawer, tapbar 등과 같은 Material Design 구성요소를 구현합니다.\nScaffold는 일반적으로 MaterialApp위젯 내애서 사용되며, 앱의 뼈대를 제공하고, 많은 Material Design 구성요소를 간단하게 구현할 수 있기 때문에, Flutter앱을 개발할 때 매우 유용한 위젯 중 하나입니다.\nScaffold 위젯은 body속성을 통해 앱의 기본 컨텐츠를 정의하며, appBar속성을 통해 상단의 앱 바를 정의할 수 있습니다.\n또한, drawer속성을 사용하여 측면 드로어를 추가하거나 bottomNavigationBar속성을 사용하여 하단의 탭바를 추가할 수도 있습니다.\nparameter Scaffold의 parameter는 다양하지만, 우리는 가장 범용적으로 사용하는 기능에 대해 다룰 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Scaffold extends StatefulWidget { const Scaffold({ super.key, this.appBar, this.body, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.persistentFooterAlignment = AlignmentDirectional.centerEnd, this.drawer, this.onDrawerChanged, this.endDrawer, this.onEndDrawerChanged, this.bottomNavigationBar, this.bottomSheet, this.backgroundColor, this.resizeToAvoidBottomInset, this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.start, this.extendBody = false, this.extendBodyBehindAppBar = false, this.drawerScrimColor, this.drawerEdgeDragWidth, this.drawerEnableOpenDragGesture = true, this.endDrawerEnableOpenDragGesture = true, this.restorationId, }) Appbar Application 최상단에 위치하고 있는 bar를 말합니다. 아래와 같이 Scaffold생성자에 AppBar를 전달하면 생성할 수 있습니다.\n자세한 내용은 Appbar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), //타이틀 제목 centerTitle: true, //타이틀 가운데 정렬 (true/false) ), ); } } backgroundColor / foregroundColor 상단바의 배경색(backgroundColor) / 타이틀색(foregroundColor)를 지정할 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), backgroundColor: Colors.green, //상단바 배경색 foregroundColor: Colors.black, //상단바 타이틀색 ), ); } } elevation / shadowColor 상단바에 그림자효과를 줄 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), elevation: 10, //상단바 Shadow 깊이 shadowColor: Colors.red, //상단바 Shadow 색 ), ); } } leading / actions 상단바에 앞(leading)/뒤(actions)에 아이콘과 같은 위젯들을 추가하고 버튼 아이콘으로 onPressed도 실행할 수 있음\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), leading: const Icon(Icons.ac_unit), //상단바 타이틀 앞에 위젯추가 actions: [ //상단바 타이틀 뒤에 위젯추가 IconButton( icon: const Icon(Icons.photo_album), tooltip: \u0026#39;Hi!\u0026#39;, onPressed: () =\u0026gt; {}, ), IconButton( icon: const Icon(Icons.pie_chart), tooltip: \u0026#39;Wow\u0026#39;, onPressed: () =\u0026gt; {}, ) ], automaticallyImplyLeading: true, //뒤로가기 버튼 true(존재O)/false(존재X) centerTitle: true, //타이틀 가운데 정렬 ), ); } } Body Appbar의 중간영역이며, body는 하나의 Widget만 가질 수 있으며 메인 화면에 보여질 내용을 주로 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), body: Center( child: Column( children: const [ Text(\u0026#39;1\u0026#39;), Text(\u0026#39;2\u0026#39;), Text(\u0026#39;3\u0026#39;), Text(\u0026#39;4\u0026#39;), Text(\u0026#39;5\u0026#39;), Text(\u0026#39;6\u0026#39;), ], ), ), ); } } Bottom Navigation Bar 앱 하단에 다른 뷰를 볼 수 있도록 메뉴바를 표시해주는 위젯입니다. 보통 페이지 별 바로가기 작업을 제공하기위해 만들어집니다.\n자세한 내용은 BottonNavigationBar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), bottomNavigationBar: BottomNavigationBar( items: const \u0026lt;BottomNavigationBarItem\u0026gt;[ BottomNavigationBarItem( icon: Icon(Icons.text_snippet), label: \u0026#39;나의 판매글\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.home), label: \u0026#39;홈\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.people), label: \u0026#39;마이페이지\u0026#39;, ), ], selectedItemColor: Colors.lightGreen, ), ); } } Floating Action Button 화면에 Fixed되는 원형 아이콘 버튼이며 일반적으로 화면 맨 하단 오른쪽에 위치하게 됩니다. Android 개발자들은 줄여서 FAB라고 부른다고 합니다. Icon뿐만아니라 Text로도 위젯을 사용할 수 있습니다.\n자세한 내용은 FloationActionButton Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), floatingActionButton: FloatingActionButton.extended( label: const Text(\u0026#39;Approve\u0026#39;), icon: const Icon(Icons.thumb_up), backgroundColor: Colors.pink, onPressed: () =\u0026gt; {print(\u0026#39;hello\u0026#39;)}, ), ); } } ","date":"2023-04-18T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-scaffold-widget/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-scaffold-widget/","title":"[Flutter] Scaffold Widget"},{"content":"Dart란? Dart는 구글이 디자인한 멀티 플랫폼 프로그래밍언어입니다.\n자바스크립트를 대체할 수 있는 크로스 플랫폼 프로그래밍 언어를 목표로 설계했다고 합니다.\nDart는 Flutter에서 사용되는 언어이며 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다.\nUI 최적화용 : 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발\n생산적인 개발 : 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인\n모든 플랫폼에서 빠름 : 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript로 컴파일\nDart 공식 사이트\n사이트에 본 설명에 의하면 Dart는 두 개의 컴파일러를 가지고 있다.\nDart Web : Dart로 쓴 코드를 javascript로 변환해주는 컴파일러 Dart Native : Dart로 쓴 코드를 여러 CPU의 아키텍쳐에 맞게 변환해주는 컴파일러 (ARM32, 모바일인 ARM64(IOS, Android), 데스크탑인 x86_64(Mac, Linux, Windows) 등등에 맞게 변환해준다는 의미) JIT, AOT Dart는 또 어떻게 컴파일 되는지에 대해 JIT, AOT로 볼 수 있다.\nJIT(Just-In-Time) : 개발 중에는 수정된 코드가 결과로 바로 나타날 수 있게끔 만드는 컴파일러로 Dart VM(Virtual Machine)을 사용하여 Just-In-Time 컴파일러를 제공합니다. AOT(Ahead-of-time) : 배포를 할 때에는 더이상 Dart VM(Virtual Machine)을 사용하지 않고 Ahead-Of-Time 컴파일러를 제공하여 각 아키텍쳐에 맞는 기계어로 컴파일이 되고 앱을 더 빠르게 실행시킬 수 있게 만듭니다. 이러한 특징을 갖는 것은 모바일 개발에 있어서 아주 중요하고 멋진 특징입니다. 개발 중에 바로바로 피드백을 확인할 수 있고, 앱을 배포할 때에는 휴대폰, 노트북, 웹사이트에서 기계어를 실행하여 편하게 배포를 할 수 있습니다.\nnull safety 다른 언어에서는 코드에서 null 값을 참조해버리면 오류가 발생하여 더 이상 동작을 할 수 없게 만들지만, Dart는 이러한 문제를 방지하기 위해 null safety라는 것을 도입했습니다.\n결론 Flutter는 Dart라는 언어를 사용하는데 둘 다 구글에서 제작한 것이므로 Dart는 Flutter를 위한 언어라고 볼 수 있습니다. 그래서 Flutter에서의 Dart언어를 최적화하고싶다면 수정을 할 수 있다는 큰 장점이 있습니다.\n이것이 중요한 이유는 React나 Vue는 언어에 대해 최적화를 하고싶다고 하여도 javascript를 수정할 수 없습니다. 다른 언어들도 마찬가지입니다. 그렇기때문에 이 점은 매우 강한 장점으로 보이며 그 속에 또 다른 단점이 존재할 수 있습니다. 하지만, RN에 비해 Flutter의 사용비율이 급격히 증가해지면서 커뮤니티가 활성화되고있고 더 많은 기능을 기대할 수 있을 것 같습니다.\nFlutter에 관심이 많다면 한번 배워보는 것도 좋을 것 같습니다.\n","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/dart-logo_hu6ca51b6ea6e3939baa7b81d018f1cfc2_224667_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/","title":"[Dart] Flutter에서 사용하는 Dart언어란?"},{"content":"Flutter란? Flutter는 Google에서 개발한 크로스 플랫폼 모바일 앱 개발 프레임워크\n크로스 플랫폼 모바일 앱 개발 프레임워크란?\niOS나 Android 두 OS에 대해 하나의 코드베이스로 관리하여 여러 플랫폼에 동시에 서비스를 제공하기 위한 프레임워크\nNative vs Cross Platform vs Hybrid 앱 서비스 개발시 3가지 방법으로 서비스를 제공할 수 있습니다.\n네이티브 앱 크로스 플랫폼 프레임워크 하이브리드 앱 네이티브 앱 네이티브 앱은 플랫폼의 네이티브 언어와 프레임워크를 이용해 개발하며 기기에 맞게 어플리케이션을 개발할 수 있지만, 여러 플랫폼에서 제공하기 위해서는 각각 개발을 할 수 있어야함\n크로스 플랫폼 프레임워크 크로스 플랫폼 프레임워크는 하나의 코드베이스로 여러 플랫폼을 관리 및 서비스할 수 있으며 자바스크립트, C#, Dart를 안다면 개발을 시작할 수 있음\n하이브리드 앱 하이브리드 앱은 웹페이지를 웹뷰로 감싸서 플랫폼처럼 서비스를 제공할 수 있으며 웹개발로 앱도 동시에 개발할 수 있고, 앱과 같은 경험을 만들어 줄 수 있음\n자세한 내용은 추후에 더 포스팅을 하여 각 방법의 특장점을 살펴보도록 하겠습니다.\n그렇다면 왜 Flutter는 CrossPlatform을 사용할까요? 모바일의 경우 iOS와 Android 개발자가 각각 있다면 CrossPlatform으로 개발하지 않아도 됩니다. 하지만, 각 OS별로 유저들에게 동일한 UI/UX를 제공하면서 개발하는 것은 결코 쉬운일이 아닙니다. 또, 각 OS별로 개발자가 필요하다보니 개발자원이 2배 이상 필요하게 됩니다. 그리고, 한명의 개발자가 두 OS 모두 개발한다고 하더라도 각 OS의 개발방식이 서로 다르기때문에 시간도 많이 소요됩니다.\n개발을 완료했다쳐도 각 OS마다 앱의 유지보수가 쉽지 않다는 단점이 있습니다.\n그래서 크로스 플랫폼을 사용한다면 개발 자원과 시간을 줄일 수 있으며, 하나의 프레임워크로 Android, iOS 둘 다 동시에 개발이 가능해집니다. 유지보수 측면에서도 하나의 코드베이스로 되어있다보니 훨씬 편리하게됩니다.\n기존의 앱 시장에서는 React Native가 시장을 장악하고 있었지만, Flutter가 나온 후로 많은 개발자들이 유입되었고 커뮤니티또한 활발하게 성장하고 있습니다.\n2023년 2월 기준으로 Stack Overflow Survey 2022에서 나온 결과를 보면 Flutter가 간소한 차이로 우위를 하고 있는 것을 볼 수 있습니다.\nThe results of the annual Stack Overflow Survey 2022\n또 아래에는 React Native와 Flutter의 비교영상입니다.\nhttps://www.youtube.com/watch?v=BqGxJ_ybE6k\nFlutter는 어떤 언어를 사용하나요? Flutter는 Dart라는 언어를 사용합니다. 이 Dart언어 또한 구글에서 개발한 언어입니다.\n기존의 앱 개발자들에게는 또 다시 언어를 배워야한다는 단점이 있지만, 문법자체가 그렇게 어렵진 않은 것 같아 어느정도 개발을 하셨던 분들이라면 빠르게 적응하실 수 있을 것입니다.\nDart에 대하여 더 궁금한 내용은 Flutter에서 사용하는 Dart언어란?을 봐주세요.\nFlutter의 특징 장점\n통합 개발 환경지원\nFlutter는 다양한 Editor(Android Studio, VS Code 등등)를 사용하여 빌드가 가능합니다. Android Studio는 Flutter Inspector와 Flutter Outline이라는 개발 도구를 추가적으로 지원해줍니다. VS code 에서는 간단하게 Extension 으로 Flutter를 설치하여 Flutter를 사용할 수 있습니다.\n성능 문제해결\n기존 React Native 혹은 Hybrid App의 경우 네이티브 브릿지를 통한 통신이 불가피했습니다.\n하지만 Flutter는 직접 컴파일되서 Render를 직접 하기때문에 성능이 빠릅니다. 애니메이션 속도가 60프레임은 가뿐히 넘어서는 것이 기존 크로스 플랫폼시장의 주류였던 React Native와 Flutter를 비교하는 많은 글들에서 Flutter를 내세우는 부분입니다.\nMateiral Design \u0026amp; Cupertino\nFlutter는 Androd와 iOS의 대표 디자인 가이드를 기본적으로 제공합니다. 구글의 머티리얼 디자인(Material Design)의 홈페이지에는 이미 Flutter가 포함되어 있고 가이드만 제공하는 것 뿐만아니라 Flutter 프로젝트에 바로 추가하여 사용할 수 있는 패키지도 제공합니다.\n안드로이드와 iOS에서 같은 머티리얼 디자인을 사용하더라도 플랫폼에 따라 다르게 출력되는 부분을 각각 디자인 가이드에 맞게 화면을 그립니다. iOS앱을 개발하는 경우 iOS특유의 디자인 시스템인 쿠퍼티노(Cupertino) 위젯을 제공합니다.\n그렇기에 선택의 폭이 정해져 있기 때문에 어떤 UI 라이브러리를 사용할 것인지 고민 할 필요가 없습니다만 이건 장점이자 단점이 될수도 있습니다.\nDart뿐만 아니라 Native코드도 사용\n앞서 Dart를 사용한다고 했지만 결국엔 크로스 플랫폼이기에 해당 OS에 최적화된 앱을 만들려면 Native 코드를 사용할수밖에 없고 Dart와 섞어서 사용을 합니다. 즉, Dart만 사용하는것이 아니라 Android면 Kotlin, iOS면 Swift도 사용합니다. 이는 기존의 Native 코드를 사용한 개발자라면 장점이 됩니다.\n단점\nNative API를 Dart에서 직접 호출 불가\n특별히 심하게 문제가 되진 않지만 외부 플러그인을 써야합니다.\n코드를 고치려면 새 버전을 배포\nReact Native, Cordova, Ionic 에선 이미 지원 중 입니다.\nhttps://github.com/flutter/flutter/issues/14330\nAir bnb Lotti 지원 X\nFlutter는 지원하지 않습니다. Android, iOS, React-Native만 지원\nLotti는 어플리케이션에 Fancy한 애니메이션을 넣어주는 라이브러리입니다.\nhttps://airbnb.design/lottie/\nWearable 디바이스앱에 약함\n플러그인이 존재는 하지만 Native처럼 쉽게 되지는 않습니다.\nC/C++ 라이브러리 호출 불가\nNDK C/C++ 라이브러리 호출이 Dart에서 안됩니다. 외부 플러그인을 써야하고, 원하는 플러그인이 없다면 만들어야 하는데 이는 보통일이 아닙니다.\n지원되는 플러그인이 부족\n아직 플러그인들은 부족한 편입니다. 어플을 생성할 때, Webview, Map 등 플러그인은 필요합니다.\n하지만 Flutter의 이러한 플러그인들은 전부 0.4, 0.3 등등 1.0을 넘는 버전을 보기가 힘듭니다. 따라서 지속적으로 업데이트가 되고있고, 업데이트가 될때마다 다시 붙이고 테스트해보는 것은 어마어마하게 번거로운 일이 될 것입니다.\n아직까진 국내에 개발관련 자료가 많이 없음\nndroid, iOS Native는 나온지 오래되서 자료가 많다보니 문제해결이 쉽습니다만, 국내엔 아직까진 자료가 많다고 할수가 없어 이슈 상황 발생시 자료 찾기가 어렵습니다.\n또한, Flutter 개발자들도 그렇게 많은 편이 아니기에 도움을 구하기도 어느정도 힘이 듭니다.\n결론 점점 성장 중이며 React Native보다 사용을 많이한다고는 하지만, 아직 플러그인이 부족한 것은 사실이며 소규모로 빠르게 시작하기 위해서는 Flutter를 사용하는게 맞겠지만, 어느정도 규모가 있다면 각각의 OS에 맞는 전문 개발자를 뽑아서 개발하는 것이 질적으로 더 가치가 있을 것 같습니다.\n아직 국내에 많은 레퍼런스가 없긴 하지만 학생으로서 Flutter로 빠르게 서비스를 제공하는 경험을 해보는 것도 괜찮을 것 같습니다. 기본적으로 괜찮은 기능들이 많고 React Native에서 힘들게 작업해야 하는 것을 Flutter에서는 손쉽게 구현하는 것도 코린이로서 이점이 될 수도 있습니다.\nFlutter도 외국에 생각보다 많은 서비스를 하고있으며 지속적으로 업데이트되고 더 안정화가 된다면 강력한 프레임워크가 되지 않을까 생각합니다.\n참고자료 https://blog.mayleaf.dev/24\nhttps://velog.io/@jojo_devstory/Flutter%EB%9E%80-Flutter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90#4-flutter%EC%9D%98-%ED%8A%B9%EC%A7%95\n","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-flutter%EB%9E%80-flutter%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-flutter%EB%9E%80-flutter%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/","title":"[Flutter] Flutter란? Flutter가 무엇일까?"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-04-16T00:00:00Z","image":"https://myeongcode.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"반가워요! 앞으로 다시 포스팅 열심히하기 ✍🏻\n","date":"2023-04-16T00:00:00Z","permalink":"https://myeongcode.github.io/p/%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%83%88-%EB%8B%A8%EC%9E%A5/","title":"홈페이지 새 단장"},{"content":"문제 풀이 (처음 생각한 답)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { float a, b, result; scanf(\u0026#34;%f %f\u0026#34;, \u0026amp;a, \u0026amp;b); result = a / b; printf(\u0026#34;%.10f\u0026#34;, result); return 0; } 하지만, 위의 문제에서 출력부분을 보면 ‘실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$이하이면 정답’ 이라고 표시되어 있다.\n이게 무슨말이냐?\n먼저 float으로 받아서 float으로 출력을 해보면 다음과 같이 나옵니다.\n실제 답은 0.333333333333…이 나와야하는데 0.3333333433이 출력이 됩니다.\n그러면 실제 답과의 절대오차는 0.0000000100…이 됩니다.\n절대오차가 1 * 10^{-8}만큼 차이나므로 10^{-9}이하가 아니게 됩니다\n1 * 10^{-8} \u0026gt; 10^{-9}\n그러면 상대오차로 계산해보겠습니다.\n상대오차는 배율로 생각하면 편합니다. 원래 답과의 차이가 +-10까지 허용한다 그러면 상대오차는 10^{-1}까지 허용하는 셈입니다. +-1까지 허용한다하면 10^{-2}까지 허용하는겁니다.\n그렇다면, 0.3333333333과 0.3333333433의 상대오차는 어떻게 될까요\n공식을 이용하면\n상대오차 = {1*10^{-8}}{0.3333333333} * 100 = 0.000003\n배율만큼 차이가 난다는 의미입니다. 그러므로 상대오차 또한 10^{-9}보다 크므로 상대오차도 오답이 되는 것입니다.\n그러면 어떻게 해야하냐면 정밀도가 더 큰 자료형으로 바꾸면 됩니다.\nfloat보다는 double의 정밀도가 더 큽니다.\nfloat과 double의 범위또한 다르며 유효자릿수가 double이 더 크기때문에 더 정밀하다는 의미가 됩니다.\n따라서, 백준에서는 더 정밀한 값을 정답으로 처리하겠다는 것입니다.\n그럼 자료형을 float이 아닌 double로 바꿔서 출력해보겠습니다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { double a, b, result; printf(\u0026#34;-------input-------\\n\u0026#34;); scanf(\u0026#34;%lf %lf\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;\\n\u0026#34;); result = a / b; printf(\u0026#34;-------output-------\\n\u0026#34;); printf(\u0026#34;%.10lf\\n\u0026#34;, result); return 0; } ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1008번 문제"},{"content":"문제 풀이 이 문제는 C언어로 풀어봤지만, C언어에서 정수형의 표현 범위는 long을 이용해도 2,147,483,647정도로 10의 1000승에 비하면 터무니없이 작은 수이기 때문에 계산할 수 있는 범위를 벗어나서 오버플로우가 발생했고, 출력값이 잘못 나오게 되는겁니다.\n따라서, 이 문제는 C가 아닌 파이썬을 이용하면 훨씬 더 쉽게 풀 수 있다는 것을 알았습니다.\n왜냐하면 파이썬은 큰 수를 자동으로 처리해주기 때문이죠.\n1 2 3 4 m, n = map(int, input().split()) print(m // n) print(m % n) ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1271번 문제"}]
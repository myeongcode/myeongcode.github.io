[{"content":"Dart란? Dart는 구글이 디자인한 멀티 플랫폼 프로그래밍언어입니다.\n자바스크립트를 대체할 수 있는 크로스 플랫폼 프로그래밍 언어를 목표로 설계했다고 합니다.\nDart는 Flutter에서 사용되는 언어이며 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다.\nUI 최적화용 : 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발\n생산적인 개발 : 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인\n모든 플랫폼에서 빠름 : 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript로 컴파일\nDart 공식 사이트\n사이트에 본 설명에 의하면 Dart는 두 개의 컴파일러를 가지고 있다.\nDart Web : Dart로 쓴 코드를 javascript로 변환해주는 컴파일러 Dart Native : Dart로 쓴 코드를 여러 CPU의 아키텍쳐에 맞게 변환해주는 컴파일러 (ARM32, 모바일인 ARM64(IOS, Android), 데스크탑인 x86_64(Mac, Linux, Windows) 등등에 맞게 변환해준다는 의미) JIT, AOT Dart는 또 어떻게 컴파일 되는지에 대해 JIT, AOT로 볼 수 있다.\nJIT(Just-In-Time) : 개발 중에는 수정된 코드가 결과로 바로 나타날 수 있게끔 만드는 컴파일러로 Dart VM(Virtual Machine)을 사용하여 Just-In-Time 컴파일러를 제공합니다. AOT(Ahead-of-time) : 배포를 할 때에는 더이상 Dart VM(Virtual Machine)을 사용하지 않고 Ahead-Of-Time 컴파일러를 제공하여 각 아키텍쳐에 맞는 기계어로 컴파일이 되고 앱을 더 빠르게 실행시킬 수 있게 만듭니다. 이러한 특징을 갖는 것은 모바일 개발에 있어서 아주 중요하고 멋진 특징입니다. 개발 중에 바로바로 피드백을 확인할 수 있고, 앱을 배포할 때에는 휴대폰, 노트북, 웹사이트에서 기계어를 실행하여 편하게 배포를 할 수 있습니다.\nnull safety 다른 언어에서는 코드에서 null 값을 참조해버리면 오류가 발생하여 더 이상 동작을 할 수 없게 만들지만, Dart는 이러한 문제를 방지하기 위해 null safety라는 것을 도입했습니다.\n결론 Flutter는 Dart라는 언어를 사용하는데 둘 다 구글에서 제작한 것이므로 Dart는 Flutter를 위한 언어라고 볼 수 있습니다. 그래서 Flutter에서의 Dart언어를 최적화하고싶다면 수정을 할 수 있다는 큰 장점이 있습니다.\n이것이 중요한 이유는 React나 Vue는 언어에 대해 최적화를 하고싶다고 하여도 javascript를 수정할 수 없습니다. 다른 언어들도 마찬가지입니다. 그렇기때문에 이 점은 매우 강한 장점으로 보이며 그 속에 또 다른 단점이 존재할 수 있습니다. 하지만, RN에 비해 Flutter의 사용비율이 급격히 증가해지면서 커뮤니티가 활성화되고있고 더 많은 기능을 기대할 수 있을 것 같습니다.\nFlutter에 관심이 많다면 한번 배워보는 것도 좋을 것 같습니다.\n","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/dart-logo_hu6ca51b6ea6e3939baa7b81d018f1cfc2_224667_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/","title":"[Dart] Flutter에서 사용하는 Dart언어란?"},{"content":"Scaffold란? Flutter에서 Scaffold는 Material Design에서 사용되는 앱의 뼈대(Layout)을 제공하는 위젯입니다.\nScaffold class\n역할 Scaffold는 앱의 기본적인 레이아웃 구조를 정의하고, appbar, toolbar, drawer, tapbar 등과 같은 Material Design 구성요소를 구현합니다.\nScaffold는 일반적으로 MaterialApp위젯 내애서 사용되며, 앱의 뼈대를 제공하고, 많은 Material Design 구성요소를 간단하게 구현할 수 있기 때문에, Flutter앱을 개발할 때 매우 유용한 위젯 중 하나입니다.\nScaffold 위젯은 body속성을 통해 앱의 기본 컨텐츠를 정의하며, appBar속성을 통해 상단의 앱 바를 정의할 수 있습니다.\n또한, drawer속성을 사용하여 측면 드로어를 추가하거나 bottomNavigationBar속성을 사용하여 하단의 탭바를 추가할 수도 있습니다.\nparameter Scaffold의 parameter는 다양하지만, 우리는 가장 범용적으로 사용하는 기능에 대해 다룰 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Scaffold extends StatefulWidget { const Scaffold({ super.key, this.appBar, this.body, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.persistentFooterAlignment = AlignmentDirectional.centerEnd, this.drawer, this.onDrawerChanged, this.endDrawer, this.onEndDrawerChanged, this.bottomNavigationBar, this.bottomSheet, this.backgroundColor, this.resizeToAvoidBottomInset, this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.start, this.extendBody = false, this.extendBodyBehindAppBar = false, this.drawerScrimColor, this.drawerEdgeDragWidth, this.drawerEnableOpenDragGesture = true, this.endDrawerEnableOpenDragGesture = true, this.restorationId, }) Appbar Application 최상단에 위치하고 있는 bar를 말합니다. 아래와 같이 Scaffold생성자에 AppBar를 전달하면 생성할 수 있습니다.\n자세한 내용은 Appbar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), //타이틀 제목 centerTitle: true, //타이틀 가운데 정렬 (true/false) ), ); } } backgroundColor / foregroundColor 상단바의 배경색(backgroundColor) / 타이틀색(foregroundColor)를 지정할 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), backgroundColor: Colors.green, //상단바 배경색 foregroundColor: Colors.black, //상단바 타이틀색 ), ); } } elevation / shadowColor 상단바에 그림자효과를 줄 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), elevation: 10, //상단바 Shadow 깊이 shadowColor: Colors.red, //상단바 Shadow 색 ), ); } } leading / actions 상단바에 앞(leading)/뒤(actions)에 아이콘과 같은 위젯들을 추가하고 버튼 아이콘으로 onPressed도 실행할 수 있음\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), leading: const Icon(Icons.ac_unit), //상단바 타이틀 앞에 위젯추가 actions: [ //상단바 타이틀 뒤에 위젯추가 IconButton( icon: const Icon(Icons.photo_album), tooltip: \u0026#39;Hi!\u0026#39;, onPressed: () =\u0026gt; {}, ), IconButton( icon: const Icon(Icons.pie_chart), tooltip: \u0026#39;Wow\u0026#39;, onPressed: () =\u0026gt; {}, ) ], automaticallyImplyLeading: true, //뒤로가기 버튼 true(존재O)/false(존재X) centerTitle: true, //타이틀 가운데 정렬 ), ); } } Body Appbar의 중간영역이며, body는 하나의 Widget만 가질 수 있으며 메인 화면에 보여질 내용을 주로 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), body: Center( child: Column( children: const [ Text(\u0026#39;1\u0026#39;), Text(\u0026#39;2\u0026#39;), Text(\u0026#39;3\u0026#39;), Text(\u0026#39;4\u0026#39;), Text(\u0026#39;5\u0026#39;), Text(\u0026#39;6\u0026#39;), ], ), ), ); } } Bottom Navigation Bar 앱 하단에 다른 뷰를 볼 수 있도록 메뉴바를 표시해주는 위젯입니다. 보통 페이지 별 바로가기 작업을 제공하기위해 만들어집니다.\n자세한 내용은 BottonNavigationBar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), bottomNavigationBar: BottomNavigationBar( items: const \u0026lt;BottomNavigationBarItem\u0026gt;[ BottomNavigationBarItem( icon: Icon(Icons.text_snippet), label: \u0026#39;나의 판매글\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.home), label: \u0026#39;홈\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.people), label: \u0026#39;마이페이지\u0026#39;, ), ], selectedItemColor: Colors.lightGreen, ), ); } } Floating Action Button 화면에 Fixed되는 원형 아이콘 버튼이며 일반적으로 화면 맨 하단 오른쪽에 위치하게 됩니다. Android 개발자들은 줄여서 FAB라고 부른다고 합니다. Icon뿐만아니라 Text로도 위젯을 사용할 수 있습니다.\n자세한 내용은 FloationActionButton Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), floatingActionButton: FloatingActionButton.extended( label: const Text(\u0026#39;Approve\u0026#39;), icon: const Icon(Icons.thumb_up), backgroundColor: Colors.pink, onPressed: () =\u0026gt; {print(\u0026#39;hello\u0026#39;)}, ), ); } } ","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-scaffold-widget/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-scaffold-widget/","title":"[Flutter] Scaffold Widget"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating. — Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-04-16T00:00:00Z","image":"https://myeongcode.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"반가워요! 앞으로 다시 포스팅 열심히하기 ✍🏻\n","date":"2023-04-16T00:00:00Z","permalink":"https://myeongcode.github.io/p/%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%83%88-%EB%8B%A8%EC%9E%A5/","title":"홈페이지 새 단장"},{"content":"문제 풀이 (처음 생각한 답)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { float a, b, result; scanf(\u0026#34;%f %f\u0026#34;, \u0026amp;a, \u0026amp;b); result = a / b; printf(\u0026#34;%.10f\u0026#34;, result); return 0; } 하지만, 위의 문제에서 출력부분을 보면 ‘실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$이하이면 정답’ 이라고 표시되어 있다.\n이게 무슨말이냐?\n먼저 float으로 받아서 float으로 출력을 해보면 다음과 같이 나옵니다.\n실제 답은 0.333333333333…이 나와야하는데 0.3333333433이 출력이 됩니다.\n그러면 실제 답과의 절대오차는 0.0000000100…이 됩니다.\n절대오차가 1 * 10^{-8}만큼 차이나므로 10^{-9}이하가 아니게 됩니다\n1 * 10^{-8} \u0026gt; 10^{-9}\n그러면 상대오차로 계산해보겠습니다.\n상대오차는 배율로 생각하면 편합니다. 원래 답과의 차이가 +-10까지 허용한다 그러면 상대오차는 10^{-1}까지 허용하는 셈입니다. +-1까지 허용한다하면 10^{-2}까지 허용하는겁니다.\n그렇다면, 0.3333333333과 0.3333333433의 상대오차는 어떻게 될까요\n공식을 이용하면\n상대오차 = {1*10^{-8}}{0.3333333333} * 100 = 0.000003\n배율만큼 차이가 난다는 의미입니다. 그러므로 상대오차 또한 10^{-9}보다 크므로 상대오차도 오답이 되는 것입니다.\n그러면 어떻게 해야하냐면 정밀도가 더 큰 자료형으로 바꾸면 됩니다.\nfloat보다는 double의 정밀도가 더 큽니다.\nfloat과 double의 범위또한 다르며 유효자릿수가 double이 더 크기때문에 더 정밀하다는 의미가 됩니다.\n따라서, 백준에서는 더 정밀한 값을 정답으로 처리하겠다는 것입니다.\n그럼 자료형을 float이 아닌 double로 바꿔서 출력해보겠습니다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { double a, b, result; printf(\u0026#34;-------input-------\\n\u0026#34;); scanf(\u0026#34;%lf %lf\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;\\n\u0026#34;); result = a / b; printf(\u0026#34;-------output-------\\n\u0026#34;); printf(\u0026#34;%.10lf\\n\u0026#34;, result); return 0; } ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1008번 문제"},{"content":"문제 풀이 이 문제는 C언어로 풀어봤지만, C언어에서 정수형의 표현 범위는 long을 이용해도 2,147,483,647정도로 10의 1000승에 비하면 터무니없이 작은 수이기 때문에 계산할 수 있는 범위를 벗어나서 오버플로우가 발생했고, 출력값이 잘못 나오게 되는겁니다.\n따라서, 이 문제는 C가 아닌 파이썬을 이용하면 훨씬 더 쉽게 풀 수 있다는 것을 알았습니다.\n왜냐하면 파이썬은 큰 수를 자동으로 처리해주기 때문이죠.\n1 2 3 4 m, n = map(int, input().split()) print(m // n) print(m % n) ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1271번 문제"}]
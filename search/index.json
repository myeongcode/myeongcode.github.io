[{"content":"개요 우리는 코딩을 하면서 알고리즘이라는 것을 흔하게 마주하고 개발자라면 피할 수 없는 개념이 바로 알고리즘이다.\n그렇다면, 알고리즘이 뭔지 왜 우리가 알고리즘을 알고 사용해야하는지를 알아야 합니다. 학교에서 알고리즘에 대한 내용들을 배우면서 tree, stack, queue등 다양한 자료구조가 있는지를 공부했다. 하지만, 이 알고리즘이라는 것을 사용하는 이유에 대해 설명하라고 한다면, 순간 뇌정지가 오며 어버버 할 가능성 100%\n그래서.. 알고리즘에 대해서 나만의 방식으로 정리하고 누군가가 물어봤을 때에도 이해를 잘 시켜줄 수 있을만큼 정리를 하려한다.\n알고리즘? 우리는 알고리즘이 탄생하게 된 이유를 알아야 한다.\n살다보면 어떠한 문제를 앞에 놓고 막연하게 어떻게 해결해야 하는지에 대해 고민을 해야할 때가 있다. 그럴 때 우리는 문제들을 해결하기 위한 여러 동작을 하게되는데 이것들을 수학적으로 계산하여 추론하기 위한 ‘일련의 단계적 절차’이자 ‘동작들의 모임’이라고 한다.\n즉, 알고리즘이란 문제점을 해결하기 위한 방법과 절차이다.\n예를 들어, 학생 100명의 시험 점수의 평균을 내야한다고 했을 때 당신이라면 어떻게 해결하겠습니까?\n물론 100명의 시험 점수를 모두 더해서 100으로 나누면 되겠지만.. 1000명, 1만명의 시험 점수를 평균 내야한다고 했을 때에도 똑같은 방법으로 할 수 있을까? 아마 시간과 효율이 많이 떨어지게 될 것이다.\n그래서 우리는 이런 문제를 해결할 때는 시간과 효율성을 중요하게 생각해야 한다.\n특히나 어떤 입력을 받고 연산을 처리하여 결과를 출력해야하는 개발자에게는 더욱 더 시간과 효율이 중요하기에 알고리즘이라는 해결 과정을 통해 효율적으로 결과를 만들어 내는 것\n그래서 이런 해결 과정을 어떻게 설계 할건지에 따라 시간과 효율이 나누어지게 된다.\n우선 우리는 알고리즘을 설계하기 위해서는 해야 할 작업을 명확하게 명시해야한다. 즉, 설계하려는 알고리즘이 무엇을 하는지 입력과 출력으로 명시할 수 있다. 알고리즘에서 우리가 따져봐야하는건 이 알고리즘의 효율성, 명확성이다\n이 효율성을 평가하기 위해 알고리즘의 성능을 나타내는 척도로는 크게 공간복잡도(space complexity), 시간복잡도(time complexity) 로 나타낼 수 있다. 즉, 어떤 알고리즘이 효율적인지를 판단하는 척도\n공간복잡도(space complexity) : 프로그램 실행과 완료에 얼마나 많은 공간(메모리)가 필요한지에 대한 지표 시간복잡도(time complexity) : 프로그램 완료에 얼마나 빠르게 실행(얼마나 많이 연산)되는지에 대한 지표 즉, 특정 크기의 입력을 기준으로 할 때 필요한 연산의 횟수 보통은 시간복잡도를 위주로 알고리즘의 성능을 판단하기에 시간 복잡도에 대해서 자세히 알아야한다.\n시간복잡도 (Time complexity) ⇒ 시간복잡도는 연산 횟수를 세는 것\n*왜 시간복잡도라고 말하면서 실행 시간이 아니라 연산 횟수를 세는 것일까? ⇒ 모든 OS, IDE, 플랫폼에서 동일한 결과가 나오지 않기 때문에 연산 횟수로 사용\n하지만, 이렇게 연산 횟수도 어떤 경우인지에 따라 시간 복잡도가 나뉘어진다. 경우는 아래와 같이 3가지로 나뉜다.\n최선의 경우 (Best Case) ⇒ 최적의 입력을 한 상태에서, 작업을 완료하는 데 가장 연산 횟수가 적은 경우 최악의 경우 (Worst Case) ⇒ 최악의 입력 한 상태에서, 작업을 완료하는 데 가장 연산 횟수가 많은 경우 평균의 경우 (Average Case) ⇒ 여러 경우의 수를 고려하여, 총 연산 횟수를 계산하고 시행 횟수로 나눈 경우 알고리즘 분석 시 평균의 경우와 최악의 경우가 가장 많이 활용되며, 알고리즘이 복잡해질수록 평균을 구하기 어려워져 최악의 경우로 알고리즘 성능을 파악한다.\n예시를 통해 시간 복잡도에 대해 알아봅시다.\n1 2 3 4 5 6 algorithm ArrayMax(A,n): currentMax = A[0]············(ㄱ) for i = 1 to n-1 do···········(ㄴ) if currentMax \u0026lt; A[i]:········(ㄷ) currentMax = A[i]········(ㄹ) return currentMax 위와 같은 배열 A에서 최대값을 리턴하는 알고리즘이 있을 때, 입력값과 출력값은 아래와 같다.\n입력값 : n개의 정수를 갖는 배열 A 출력값 : A의 수 중에서 가장 큰 값 출력값은 어쨋든 A 중에서 가장 큰 값을 출력해주면 됩니다. 반면, 입력값은 어떤 것이 들어올지 알 수 없습니다.\n몇 개의 정수를 가진 배열이 입력될지 배열A의 숫자는 어떤 것이 들어갈지 어떤 정수의 숫자 n이 들어올지 예상할 수 없습니다.\n그렇기에 어떤 입력이 들어와도 이 WTC(Worctcase Time Complexity)보단 수행 시간이 적기때문에 WTC로 최대로 연산했을 때의 시간복잡도를 측정할 수 있습니다. 여기서 만약 A=[4, 3, 2, 1, …]과 같이 계속 줄어들게 된다면 0번째 인덱스가 가장 크기때문에 (ㄹ)번 문장을 실행하지 않게 됩니다. 하지만, A=[1, 2, 3, 4, …]과 같이 계속 증가하는 숫자가 있다고 한다면 (ㄹ)번 문장을 계속해서 실행해야 합니다. (ㄹ)번 문장을 실행한다는 것은 대입 연산을 한번 더 해야하고 알고리즘 수행 시간이 증가하게 됩니다.\n모든 입력값에 대한 시간복잡도는 일반적으로 T(n)으로 표기합니다.\n예를들어, n=5이고 A=[3, -1, 9, 2, 12]라고 가정해보자.\n(ㄱ) A[0]의 값 3은 currentMax에 저장이 되면서 대입연산을 합니다. (1회)\n(ㄴ) 반복문을 실행합니다.\nA[1]과의 비교\n(ㄷ) 현재 currentMax에 저장되어있는 값 3이 A[1]의 값 -1보다 작은지 비교연산을 합니다 (2회)\n비교 결과 currentMax의 값이 더 크므로 (ㄹ) 문장을 건너뛰게 됩니다.\nA[2]와의 비교\n(ㄷ) 현재 currentMax에 저장되어 있는 값 3이 A[2]의 값 9보다 작은지 비교연산을 합니다. (3회)\n(ㄹ) 비교 결과 A[2]의 값이 더 크므로 (ㄹ) 문장을 실행시키고 A[2]의 값인 9를 currentMax에 대입연산을 합니다. (4회)\nA[3]와의 비교\n(ㄷ) 현재 currentMax에 저장되어 있는 값 9가 A[3]의 값 2보다 작은지 비교연산을 합니다. (5회)\n비교 결과 currentMax의 값이 더 크므로 (ㄹ) 문장을 건너뛰게 됩니다.\nA[4]와의 비교\n(ㄷ) 현재 currentMax에 저장되어 있는 값 9가 A[4]의 값 12보다 작은지 비교연산을 합니다. (6회)\n(ㄹ) 비교 결과 A[4]의 값이 더 크므로 (ㄹ) 문장을 실행시키고 A[4]의 값인 12를 currentMax에 대입연산을 합니다. (7회)\n이렇게 총 7회의 기본 연산을 진행하게 됩니다. (반복문 제외) 이렇게 연산을 할 때 안 할때에 따라 연산 횟수가 달라지게 되는데, 여기서 Worstcase의 경우면 (ㄹ)문장이 매 조건마다 실행되었을 때를 가정하는겁니다. 그래서 이때 Worstcase는 총 9번의 연산을 하게 되는겁니다.\n반복문 안 (ㄷ), (ㄹ) 문장을 보면, (ㄷ)문장에서 비교 연산 1회, (ㄹ)문장에서 대입연산 1회를 실행합니다. (ㄴ) 문장에서 for문은 1부터 n-1까지 총 n-1회 실행하게 됩니다. 따라서, (ㄷ), (ㄹ) 문장 2회 * 반복문 n-1회 → 2(n-1) = 2n-2가 됩니다. 하지만 (ㄱ) 문장에서 대입연산도 1회 더해야하기 때문에 2n-2+1을 하게되면 시간복잡도는 총 T(n) = 2n-1이 됩니다. 그럼 n=100일 때의 시간복잡도(연산 횟수)를 손쉽게 구할 수 있습니다. *n=100, T(100) = 2 * 100 - 1 = 199번의 연산 횟수를 갖게됨.\n예시1) sumEven함수의 시간 복잡도 구하기 배열A에서 짝수인 수 만을 더하는 함수의 시간복잡도 T(n)을 구해보자.\n1 2 3 4 5 6 algorithm sumEven(A,n): sum=0··············(ㄱ) for i=0 to n-1 do········(ㄴ) if A[i]%2 == 0:···· ··(ㄷ) sum+=A[i]········(ㄹ) return sum 해당 알고리즘에서 worst case는 (ㄹ)이 계속해서 실행되는 경우이다. 그러기 위해선 (ㄷ)의 조건이 항상 참이여야하므로 A[i]%2 == 0이 되려면 A의 배열은 모두 짝수여야한다.\nA배열의 모든 값이 짝수라고 가정하면 수행시간은 다음과 같을 것이다.\n(ㄱ) 문장에서 대입연산 수행 (1회) (ㄴ) 반복문 0부터 n-1까지 n번 반복 (총 2회) (ㄷ)에서 A[i]%2 (산술연산) 수행 (2회) (ㄷ)에서 A[i]%2 == 0 (비교연산) 수행 (3회) (ㄹ)에서 sum += A[i] → sum = sum + A[i] (총 2회) (1) sum + A[i] (산술연산) 수행 (4회) (2) sum = sum + A[i] (대입연산) 수행 (5회) n번 진행하는 반복문 안에서 (ㄷ), (ㄹ) 문장을 연산 4회 진행하기 때문에 4n\n(ㄱ)문장에서 1회 진행하므로 T(n) = 4n + 1이 된다.\n예시2) 이중 for문의 sum2함수의 시간복잡도 구하기 1 2 3 4 5 6 algorithm sum2(A,n): sum=0························(ㄱ) for i=0 to n-1 do············(ㄴ) for j=i to n-1 do········(ㄷ) sum+=A[i]*A[j]·······(ㄹ) return sum 이렇게 반복문이 바로 중첩되어 있는 경우라면, 첫 번째 반복문 i와 두 번째 반복문 j의 관계를 파악해야합니다.\ni j 0 n 1 n-1 2 n-2 … … n-1 1 (1) i=0일 때, j는 n번 반복 (2) i=1일 때, j는 n-1번 반복 (3) i=2일 때, j는 n-2번 반복 … (n) i=n-1일 때, j는 1번 반복\n그렇다면, j의 경우의 수를 모두 더하면 기본 연산이 있는 반복문이 몇 번 진행되는지 알 수 있습니다. (ㄴ)는 n번 반복되고, (ㄷ)는 각 i에 대해 n-i번 반복되므로 전체 반복횟수는 다음과 같습니다.\n$$ \\sum_{i=0}^{n-1}(n-i) $$\n이므로, 이 합을 계산해보면\n$$ \\sum_{i=0}^{n-1}(n-i)=n+(n-1)+(n-2)+\u0026hellip;+1 $$\n가 됩니다. 이는 역수열의 합이고, 다음과 같이 계산할 수 있습니다.\n$$ \\sum_{k=1}^{n}k=\\frac{n(n+1)}{2} $$\n따라서, 반복 연산은 $\\frac{n(n+1)}{2}$ 번만큼 실행됩니다.\n(ㄱ) 대입 연산 수행 (1회)\n(ㄴ) 반복문 0부터 n번 수행\n(ㄷ) i에 대해 n-i번 수행\n(ㄹ) 문장\n(1) A[i] * A[j]의 산술연산 수행 (1회)\n(2) sum + A[i] * A[j]의 산술연산 수행 (1회)\n(3) sum = sum + A[i] * A[j]의 대입연산 수행 (1회)\n반복문에서 $\\frac{n(n+1)}{2}$ 회 반복을 진행하고 (ㄹ)문장에서 산술연산 2회 + 대입연산 1회 = 총 3회 연산을 진행하므로\n$$ 3\\times\\frac{n(n+1)}{2} $$\n(ㄱ)에서 대입 연산 1회를 수행하므로 $$3\\times\\frac{n(n+1)}{2} + 1$$ $$\\frac{3n^2}{2}+\\frac{3n}{2}+1$$ 따라서 T(n)은 아래와 같이 시간복잡도를 표시한다. $$T(n) = \\frac{3n^2}{2}+\\frac{3n}{2}+1$$\nBIG-O 표기법 ⇒ 주어진 함수에서 가장 빨리 증가하는 항만을 남긴채 나머지를 다 버리는 표기법\n우리는 위의 시간복잡도 $T(n)$을 통해 알고리즘의 수행시간 즉, 최악의 조건인 시간복잡도를 계산할 수 있게 되었습니다.\n위의 시간복잡도의 증가율을 위와 같이 그래프로 표시하면 $n$의 증가율에 따라 변화하는 모습을 볼 수 있습니다. 여기서 ArrayMax과 sum1(sumEven)의 최고차항은 $n$입니다. 따라서 입력한 크기 n에 대하여 선형적으로 증가하는 모습을 확인할 수 있는 반면 sum2의 최고차항은 $n^2$이므로 n에 대하여 제곱으로 증가하는 모습을 확인할 수 있습니다.\n여기서 우리는 입력한 크기 n이 커질 때, 수행 시간이 얼마나 증가하는지가 중요하다는 것을 알아야합니다. 즉, 입력값이 커질수록 함수값의 증가율은 최고차항이 좌지우지하기 때문에 상수항들은 알고리즘의 기본 연산 횟수에 큰 영향을 미치지 못합니다.\n그래서 다른 것들은 다 신경쓰지 않고 최고차항만으로 시간복잡도의 대략적인 형태를 나타낸 것을 BIG-O표기법이라 합니다. 따라서, 시간 복잡도 $T(n)$을 BIG-O로 표기하게 된다면 다음과 같이 표기할 수 있다. 분명 다른 알고리즘의 시간복잡도가 다름에도 최고차항이 같기때문에 $O(n)$으로 동일합니다.\nBIG-O 표기법은 증가율 측면에서 표기하는 것이기 때문에 크게 보면 같은 알고리즘이라고 할 수 있습니다.\n*sum2의 시간복잡도는 $\\frac{3n^2}{2}+\\frac{3n}{2}+1$이므로 BIG-O는 $O(n^2)$이라고 표시할 수 있다.\n1 2 def increment_one(a): return a+1 위와 같은 알고리즘이 있다고 할 때, $T(n)=1$이다. 이런 경우에는 최고차항은 $n^0$이므로 BIG-O표기법으로 나타내면 $O(1)$입니다.\n*정말 1번만 한다는 의미가 아니라, 어떠한 입력이 들어와도 연산 횟수가 일정하면 $O(1)$과 같이 나타냅니다.\n1 2 3 4 5 6 def number_of_bits(n): count=0 while n\u0026gt;0: n=n//2 count+=1 return count 위와 같은 알고리즘이 있다고 할 때, 입력값 n이 들어오면 2로 나눈 몫을 n에 대입하는데, 몇 번 할 수 있는지 count해서 return하는 알고리즘이 있다. 예를 들어, n=8이라면 n은 반복문을 거칠 때 마다 8 → 4 → 2 → 1 → 0 순으로 바뀌고 count는 4를 반환할 것입니다. 또한 반복문 한 번 돌 때마다, n의 값은 $\\frac{n}{2^1}$ → $\\frac{n}{2^2}$ → $\\frac{n}{2^3}$ →$\\frac{n}{2^4}$ 순으로 바뀔 것 입니다.\n결국은 $\\frac{n}{2^{count}}$가 되어야 반복문이 끝나게 되는 것이므로 $\\frac{n}{2^{count}}=1$이 됩니다.\n양변에 $2^{count}$를 곱하여 정리하면 $n=2^{count}$ 이 식의 양변에 $\\log_2$를 취하면 $\\log_2{(n)}=\\log_2{(2^{count})}$ 로그의 성질을 이용해서 오른쪽 식을 풀어쓰면 $\\log_2{(n)}=count\\cdot\\log_2{(2)}$ $\\log_2{(2)}$는 1이므로 식은 다음과 같이 단순화됩니다. $\\log_2{(n)}=count$ 따라서, $\\frac{n}{2^{count}}=1$을 n에 대해서 정리하면 $\\log_{2}{(n)}=count$가 됩니다.\n또한, while 반복문에서 n//2(산술연산) 1회, n=n//2(대입연산) 1회, count+1(산술연산) 1회, count=count+1(대입연산) 1회이므로 $4\\times\\log_2{(n)}$이고\ncount=0(대입연산)의 상수연산을 더하면 $4\\times\\log_2{(n)}+1$이 됩니다.\n따라서, $T(n)=4\\times\\log_2{(n)}+1$이 되고, $O(\\log_2n)$이 되며, 보통은 $O(\\log n)$ 이렇게 쓴다\nBIG-O 실행 순서 ⇒ 서로 다른 알고리즘의 시간복잡도의 BIG-O 다른 알고리즘이 궁금하다면 https://www.bigocheatsheet.com/\n여기까지 시간복잡도와 BIG-O에 대한 내용을 정리해봤다. 수학을 잘 못해서.. 조금 어렵긴했지만 개념정도는 확실히 정리된 것 같아 뿌듯하다. 다음으로는 자료구조는 무엇이고 자료구조에서의 시간복잡도를 살펴볼 예정이다.\nReference CHAN-GPT - [자료구조] 알고리즘 성능평가를 위한 시간 복잡도 완벽히 이해하기! - (2)\nchulgil.lee - 알고리즘의 시간복잡도와 Big-O 쉽게 이해하기\n","date":"2024-05-15T00:00:00Z","image":"https://myeongcode.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EA%B0%9C%EB%85%90-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/algo_huc18c387b622340c14205eacf60369308_36717_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EC%9D%98-%EA%B0%9C%EB%85%90-%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/","title":"알고리즘의 개념 \u0026 시간복잡도"},{"content":"문제 풀이 그냥 별찍기로 하면 쉽게 풀 수 있었는데.. 오른쪽으로 정렬해야한다고하니 어떻게 해야할지 막막했다.. 단순히 별찍기인데..\n어쨋든, 별 찍을 개수를 입력받고 입력받은 값에 별찍을 i만큼을 공백으로 채워주고 그 뒤에 *을 i만큼 출력해주도록 작성했다.\n1 2 3 4 5 6 inputCnt = int(input()) # 1부터 inputCnt까지의 범위를 설정 for i in range(1, inputCnt+1): # 입력받은 inputCnt에서 i만큼을 공백으로 채우고 뒤에 나머지를 *로 채움 print(\u0026#34; \u0026#34;*(inputCnt - i) + \u0026#34;*\u0026#34;*i) 해결완료 ✅\n","date":"2024-05-14T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-2439%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-2439%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 2439번 문제"},{"content":"문제 풀이 첫 번째 입력은 정수를 받을 개수를 입력값으로 받고, 두 번째 입력에는 최대값과 최소값을 구할 값들을 공백을 기준으로 입력받아 리스트에 정수형으로 넣어준다. 그리고나서, 해당 리스트에 있는 최대값과 최소값을 구하기 위해 python에서 사용되는 min()과max()를 사용하여 간단하게 최소값, 최대값을 얻을 수 있도록 해주었다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 정수 개수 입력받기 inputCnt = int(input()) # 값 입력받기 nums = input().split() # 받은 입력 값을 정수로 변환 nums = [int(num) for num in nums] # 입력받은 개수와 입력받은 값의 개수가 일치한다면 if(len(nums) == inputCnt): # 해당 리스트에서 최대 값을 할당 maxNum = max(nums) # 해당 리스트에서 최소 값을 할당 minNum = min(nums) print(minNum, maxNum) 해결완료 ✅\n","date":"2024-05-07T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-10818%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-10818%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 10818번 문제"},{"content":"문제 풀이 처음에 문자열 S를 입력받아서 테스트케이스로 사용하게끔 만들고, 각 문자를 R번 반복하는 새 문자열 P를 만든 후 출력하는 프로그램이다.\n첫 번째 문자는 반복할 개수, 두 번째 문자는 반복한 문자열을 입력받고, for문에서 각 인덱스의 값을 가져와서 사용하도록 작성했다.\n그리고 for문 안에 또 for문을 통해 문자열을 각 문자로 쪼개서 문자 하나하나마다 반복할 개수만큼 곱해서 값을 더해주는 것으로 코드를 작성했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 테스트 케이스 개수 입력받기 testCaseCnt = int(input()) # 테스트 케이스 개수만큼 입력받기 inputData = [input().split() for _ in range(testCaseCnt)] # 입력한 테스트케이스의 개수만큼 for문 for item in inputData: # 합칠 텍스트 변수 초기화 string = \u0026#34;\u0026#34; # 입력한 값에서 첫 번째 문자는 반복 숫자로 가져오기 number = int(item[0]) # 입력한 값에서 두 번째 문자는 반복할 텍스트 가져오기 text = item[1] # 해당 문자열의 개수만큼 for문으로 반복 for char in text: # 문자열의 각 문자는 char이 되고 해당 텍스트를 number만큼 표시해서 string에 넣어주기 string += char*number print(string) 성공은 했지만, 성공 후 다른 사람들이 푼 python코드를 살펴보던 와중에 참고하면 좋을 코드가 있어 가져와봤다.\n1 2 3 4 5 6 7 n = int(input()) for _ in range(n): # 여기에서 굳이 인덱스로 쪼개지 않고도 split을 해서 나온 첫 번째 문자와 두 번째 문자의 결과를 각각 cnt와 word에 저장시켜 줄 수 있다. cnt, word = input().split() for x in word: print(x*int(cnt), end=\u0026#39;\u0026#39;) # end=\u0026#39;\u0026#39; 옆으로 붙임 print() # 줄넘김 해결완료 ✅\n","date":"2024-05-06T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-2675%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-2675%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 2675번 문제"},{"content":"문제 풀이 최대값을 구하는 문제인 만큼 입력 값들을 서로 비교하면서 최대값에 할당을 해주면 되었다고 생각했다.\n그래서 입력을 for문으로 입력을 받았고, 타입을 확인해보니 입력은 모두 String값으로 받은 것을 확인할 수 있었다. 값 비교를 위해 해당 값을 입력받았을 때 바로 정수형(int)로 변경해주었고, 전체 입력이 완료되면 for문을 통해 값을 비교하여 값의 최대값과 몇 번째에 있는지 표시해주었다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 9개의 입력 받으면서 inputData = [int(input()) for _ in range(9)] # 큰 수 \u0026amp; 인덱스 초기화 maxNum = 0 maxNumIndex = 0 # 입력받은 값을 for for num in inputData: # 해당 인덱스의 값이 더 크면 최대 값 변수에 할당 if maxNum \u0026lt; num: maxNum = num maxNumIndex = inputData.index(num) + 1 print(maxNum) print(maxNumIndex) 해결완료 ✅\n","date":"2024-05-02T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-2562%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-2562%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 2562번 문제"},{"content":"문제 풀이 주로 자바스크립트만으로 알고리즘 문제를 진행해보다가 이제는 파이썬으로 알고리즘 문제를 해결하려고 한다.\n그렇기에 기초문제부터 차근차근 하면서 파이썬 문법과 사용법을 알아 갈 예정이다!\n가볍게 1152번 문제를 풀어봤고, 어떤 입력을 받으면 그 입력의 단어들의 개수를 출력해주는 것이였다. 자바스크립트에서의 .slice()나 .split()을 통해 단어들을 자르고 그 단어들의 개수를 출력해주면 되지 않을까 생각했고 파이썬에서도 단어들을 잘라주는 함수가 있는지 구글링을 한 결과 JS와 똑같이 .split()함수가 존재했었다.\n그래서 입력받은 값을 공백을 기준으로 split해주면 해당 단어들이 리스트(?)로 표시되는데 이 리스트들의 값만 출력해주면 돼서 쉽게 출 수 있었다.\n참고로 파이썬에서 개수를 표시하는 방법은 len()함수를 사용한다고 한다.\n1 2 3 inputData = input() print(len(inputData.split())) 해결완료 ✅\n","date":"2024-05-01T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1152%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1152%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1152번 문제"},{"content":" 어느덧 2023년이 지나고 2024년 새해가 찾아왔습니다!!\n시간이 참 빠른 것 같아요.. 한 해동안 사실 무엇을 했는지 기억도 잘 안나기도 하고 한 것도 별로 없는 것 같은데 벌써 1년이란 시간이 지나갔다는게 정말\u0026hellip;.. 무섭네요😢\n2023년의 “나” 돌아보기 “2023년에는 내가 무엇을 했을까?”란 생각이 먼저 떠오르게 됐는데, 작년 1학기가 끝나고 1년을 휴학하게 되면서 이번 9월부터 다시 학교에 복학했습니다. 휴학하면서 제가 그동안 해보고 싶었던 것들에 대한 경험을 쌓을 수 있어서 너무 좋았어요.\n그래서 이번 한 해 동안 한 것을 정리해봤습니다!\n내 적성 찾기 내가 하고싶은게 진짜 프론트엔드가 맞는지 검증하기 위해서 2022년 11월 29일부터 2023년 2월 24일까지 스마일게이트 개발캠프에서 개인 \u0026amp; 팀프로젝트를 진행했었는데요! 이때 캠프를 하면서 확실히 나는 백엔드보다는 프론트엔드가 적성에 맞는 것 같다는 계기가 되었어요.\n개인프로젝트로는 블로그를 만드는 과제를 진행했었는데요!\n프론트엔드에 관심이 생기고 얼마 되지 않아 진행한 프로젝트였어서 지금보니 한참 부족하다는 생각이 많이 들었어요ㅋㅋㅋ…\n참.. 초라한게 느껴지는 프로젝트네요\n그래도 개인프로젝트를 진행하게 되면서 서버와의 연동 React가 제공하는 기능들에 대해 조금이나마 파악할 수 있었어요\n특히, 가장 힘들었던 부분은 Web editor를 사용해서 글 작성을 수정하게 하는 기능 구현하는게 조금 어려웠어요.. 한번도 해보지 않았던거라서 더 복잡했던 것 같아요. 지금보면 아무것도 아닌데 말이죠 ㅎ..\n자세한건 제 Github에서 확인해보세요!!\nhttps://github.com/myeongcode/WinterDev\n어쨋든 개인 프로젝트가 끝나고 총 5명이서(나 포함) 팀프로젝트를 진행하게 되었는데, 사실 자유주제다 보니 주제를 기획하는게 너무 힘들었어요.. 다른 팀들은 보니까 디스코드를 클론해서 트래픽 처리 위주로 주제를 잡은 팀들도 있었고, 스마게의 게임들을 조금 변형해서 게임을 만든 팀들도 있었는데 이런거 보면 정말 기획자분들 대단하단 생각이 듭니다..!\n저희가 한 프로젝트는 “동세권”이란 매칭 커뮤니티였고, 지도와 위치를 기반으로 취미나 놀거리를 매칭해주는 서비스를 만들어보자! 해서 만들었던 프로젝트였어요\n기획은 모두가 참여했고, 프론트엔드 2명과 백엔드 3명으로 구성된 팀이였습니다!\n캠프가 총 3개월 진행됐었는데 사실상 팀프로젝트는 1개월도 안되는 시간동안 할당이 되어서 되게 빠르고 급하게 했던 것도 있긴 했었습니다.\n특히나 어려웠던 부분은 구현쪽도 있었지만, 온라인으로 거의 회의를 해서 프로젝트를 진행해야 하기도 했고 저를 제외한 나머지 분들이 모두 해외에 나가계셔서 시간차가 다르기에 회의하기가 더 어려웠다는.. 시간대가 안맞아도 열심히 회의를 참가해주고 준비해주신 우리 팀원들…. 리스펙!!!👍🏻\n자세한 프로젝트는 마찬가지로 Github에서 확인가능!\nhttps://github.com/myeongcode/DongSeGwon\n이렇게 개발캠프가 끝나고 수료증과 함께 드디어 끝났다는 생각을 하고있었지만, 사실 지금부터 시작이라는 느낌이 강하게 들었어요. 제 적성과 맞는지 검증해보기 위한 캠프였었으니까요!!\n그래도 처음 경험해본 캠프였어서 너무 좋았어요.. 사실 이게 합격이 될줄도 몰랐거든요.. 하하 운이 좋았던 것 같아요. 이런 경험을 하게 만들어준 스마게에게 너무 감사드린다는 말씀을 드리고 싶네요.. 스마게 흥해라!! 로아도 흥해라!!! (사실 나는 로아를 안한다.)\nDo It!!! 아무튼! 이제 시작이기에 프론트엔드를 길로 잡고 캠프가 끝난 후에 무엇을 해야할지 더욱더 생각해봤다. 그래서 일단 강의를 한번 들어보자! 해서 유튭에서 코딩을 재밌게 알려주시는 코딩애플님의 강의를 결제해서 들어보기도 했고, 노마드코더님의 무료 강의도 시청해보고 공부를 해봤다!!\n(여태껏 기록해왔던 내 노션..ㅎ)\n근데 사실 한 해로 봤을 때 그렇게 많이 공부한 양은 아님.. 그리고 중간중간 내가 왜 공부를 안했을까..? 어질어질하다.\n이번 한해는 다시 열심히 공부를 시작해보도록\u0026hellip; 하겠읍니다..\n아무튼!! 프론트엔드로 가기위해서 React, node, flutter, js 등등 많이 공부하긴 했는데 사실 공부보다는 프로젝트 경험을 한번 해보는게 더 중요한 것 같다. 물론 아예 노베이스로 프로젝트를 하는 것은 안되겠지만, 개발 캠프를 경험해본 나에게는 프로젝트를 하면서 알아가는게 더 큰 것 같다.\n창업의 길 4월부터는 사실 친구들과 함께 “창업”이라는 것을 생각해보게 되었고 같이 프로젝트를 할 팀원들을 모집하고, 본격적으로 5월부터 프로젝트를 시작하게 되었다. 그리고 5월부터는 내가 팀원들을 위해서 프로젝트 진행을 원활하게 하기 위해 노션에 템플릿을 꾸려놓았다.\n확실히 혼자하는게 아니다보니까 이렇게 정리한 내용이 있으면 내용 공유하기도 쉽고 우리가 뭘하고 어떤 것을 해야하는지 명확하게 보여진다. (다시생각해도 노션에 정리해놓은건 잘한 듯)\n이때 우리가 창업하려고 했던 아이템은 자아탐구를 위한 서비스 MARU(My Record And You)를 기획하게 되었었다.\n동작은 귀여운 챗봇과 대화를 하면서 내가 어떤 것을 좋아하는지, 싫어하는지, 어떤 성향을 가지고있는지를 파악할 수 있게 한 다음 ChatGPT를 사용해서 분석하게 해주고 그 지표를 사용자에게 제공해주는 서비스다.\n사실 이건 Unity로 작업을 해가지고 쉽게 할 순 없었다. 왜냐하면 모든 팀원들이 유니티를 처음 다뤄봤거든..ㅎ 그럼에도 이렇게까지 프로토타입이 나올 수 있었던데 다행 아니었나 싶음 (사실 만족하진 않았음)\n그래서 이런 아이템을 가지고 여러 공모전(교내 창업아이디어 해커톤, U-300, AI활용 해커톤 등등)에 나가서 대회를 준비하기도 했지만, 좋은 말보다는 힘들 것 같다는 말이 제일 많이 나왔었다. 특히, BM쪽으로 많이 약했다. 시장 규모도 정확히 파악할 수 없었고, 어떤 타겟을 딱 지정할 수도 없었기에 시장성이 부족하다고 평가를 많이 들었다.\n더 많은 대회를 나갔지만 상은 이렇게 밖에 없음.. 뭔가 아쉽\n창업을 준비하면서 기획부터 프로세스관리, 설계, 팀원관리, BM, 시장성 등등 파악해야할게 너무 많다보니 너무 힘들었던건 사실이다. 창업이 쉽지 않은거였구나를 다시 한번 느끼게 해준 경험이였다.\n이렇게 평가를 받고나서 계속해서 개선해나가고 변경되고 그랬지만, 변경될 수록 뭔가 우리 프로젝트의 취지에 맞지 않는 프로젝트로 변질이 된 것 같아 지금은 무산되었다. 그래도 창업에 대한 경험을 하게 되서 너무 좋았다. 앞으로도 창업을 정말 하게 된다면 조금 더 나은 방향과 신중함으로 창업을 생각해볼 수 있지 않을까?\n학교 다시 다니셔야죠? 난 2022년 하반기부터 2023년 상반기까지 휴학을 했었다. 이렇게 경험들을 하고 9월부터 다시 복학을 해야했다. 이때만해도 휴학한 1년이 이렇게 금방 갈줄 몰랐다. 이런 ㅋ 다시 휴학하고싶군\n그래도 졸업은 해야하기 때문에 복학을 했었다. 나는 20년도부터 학교를 온라인으로 다니기 시작하고 대학교에 입학하고 처음으로 학교에서 강의를 들어보는 학기였다. 내가 공부를 못하기때문에 온라인으로 다녔을 때 보다 더 힘들텐데 어떻게 학교에 다니고 수업에 집중할 수 있을까…. 엄청 걱정을 했다.\n그런데 생각보다 나는 오프라인에 맞는 사람이란걸 대면강의를 하게 되면서 알게되었다! 오히려 온라인때보다 집중이 더 되고 이해가 더 잘되는 느낌이였다. 그래서그런지 공부도 더 잘됐고, 이번학기(3학년 2학기)는 성공한 학기가 될 수 있었던 것 같다!!! 👍🏻\n이건 학교 다니면서 찍어본 우리학교!!\n우리학교 농협은행🥰 그래도 졸업하기 전에 대학생활은 즐겨봐야하지 않겠어? 라는 생각으로 밴드 동아리에 들어가서 무대도 서고 그랬다..ㅎ\n(후배가 찍어준 무대사진)\n이런것도 해보고 저런것도 해보고 싶은 나에게는 최고의 대학생활을 즐기고 있는 것 같았다 :)\n2023년의 마무리 학기를 다니면서 제대로 놀지 못했던 나는 종강하고 죽어라 놀기만 했었다ㅎ\n친구들도 만나고 술도 먹고 카페도 가고 열심히 놀음\n그리고, 2023년 12월 31일 ~ 2024년 1월 1일동안 부모님과 함께 전주와 군산 여행을 가기로 계획이 되어있었다!! 그래도 새해에는 부모님과 함께 보내는게 좋지!\n전주에서 한옥마을도 가보고 대추차도 먹어보고 성당도 가보고 야시장도 가보고 여행이지만 바쁜 일정이였음.\n거의 식도락 여행 ㅇㅈ?\n그리고 전주에서 또 제야축제가 있다고 해서 가서 내 최애 하던말던님의 노래도 직접 들어보고 폭죽과 함께 새해를 맞이했다!!!! 이런 연말을 보낸게 처음이라 태어나서 제일 행복한 새해맞이였다.\n그 다음날은 군산가서 더 먹고 더 놀았는데 다 안보여줄거임 ㅋ\n겨울바다는 이쁘니까 공유해줌\n2023년을 돌아보며 이렇게 한번 정리를 하고보니 그래도 아무것도 안하진 않았구나 하는 생각이 들었다. 내가 뭘하고싶은지 확실하게 찾을 수 있었던 해였기도 하고 창업도 경험해보고 새로운 것을 많이 경험해볼 수 있었던 해였다. 나름 만족한 한 해를 보낸게 아닐까 하는 합리화..? 하하\n2024년에는 꼭! 이제 나의 길을 정했으니 더욱 더 열심히 살아야겠다! 이제는 진짜 4학년만 남겨두고 취준을 할때가 되었다. 작년보다 더 나은 올해를 살기 위해서는 정처기 자격증도 딸거고, 토이프로젝트도 여러개 진행해보고, 토익, 더 깊은 프론트엔드 지식을 배우도록 노력할거다!\n이제는 앞으로 내가 평생 가야하는 길을 선택해야하는 단계이기 때문에 신중하고 또 고민해보고 절대 후회하지 않는 나의 길을 가도록 노력할거다. 2024년의 내 다짐은 “작년보다 더 나은 내가 되는 것”이라 마음먹고 내가 하고싶은 것 모두 이루면서 성공한 사람이 되었으면 좋겠다.\n개발도 중요하지만, 긍정적인 마인드를 우선순위로 두면 개발은 물론이고 인간관계도 더 편해지지 않을까?\n2024년도 화이팅하고 더 열심히 잘 살아보자!!!\n잘 부탁한다 청룡의 해야 :)\n","date":"2024-01-01T00:00:00Z","image":"https://myeongcode.github.io/p/2023%EB%85%84-%ED%9A%8C%EA%B3%A0-%EA%B8%B0%EB%A1%9D/2023-sea_hu59570e3aab949ecf4534181b4417c346_329119_120x120_fill_q75_box_smart1.jpeg","permalink":"https://myeongcode.github.io/p/2023%EB%85%84-%ED%9A%8C%EA%B3%A0-%EA%B8%B0%EB%A1%9D/","title":"2023년 회고 기록"},{"content":" 제 10회 대한민국 SW 융합 해커톤 대회 본선 진출! 👉🏻 현재 창업동아리에서 진행중인 아이디어로 신청하여 강원지역에 본선진출하게 되었다!\n사실.. 우리 아이디어가 신기술이 탑재되어있지도 않고, BM이 확실하지도 않지만 그래도 꾸준히 공모전이나 해커톤에 참가해서 아이템을 검증받고있다.\n우리는 또 다시한번 검증을 위해 2박 3일간 개발을 하면서 프로젝트를 완성해 나갈 것이며 팀원들과 함께 상을 얻어오자며 각오를 다졌다\nSW 융합 해커톤 👉🏻 대한민국에서 제일 크게 열리는 SW 융합 해커톤은 과기부를 중심으로 각 지역시에서 크게 열리는 대회다.\n2박 3일간 진행을 하지만 성공적인 프로젝트를 마무리하기 위해서 무박을 한 것 같다.\n아래는 해커톤에서 지정한 과제다\n자유과제 : DNA(Data, Network, A.I) 기반 SW융합 제품 또는 서비스 개발 지정과제1 : 사회문제(고령화사회, 기후문제, 디지털범죄, 스마트시티 등) 해결을 위한 SW융합 제품 또는 서비스 개발 지정과제2 : 선박 운항 데이터를 활용한 신서비스 기획 및 서비스 개발 우리는 여기서 자유과제에 신청하여 우리의 사업아이템을 한번 뽐내길 바랬다.\nWelcome to Hackathon! 우리는 학교의 지원을 받아 울산에 있는 컨벤션센터까지 KTX를 타고 갈 수 있었다.\n울산 컨벤션센터에 도착하고 나서 센터의 웅장한 자태를 봤는데.. 오우\u0026hellip;. 웅장했다\n우리는 데스크에서 등록을 진행했고 이름표를 받았다!\n기념으로 사진 한장 찰칵 📸\n드디어\u0026hellip; 2박 3일간 진행될 메인 홀을 들어왔는데 엄청 웅장했다..!! 이렇게 큰 대회에 온 것이 실감이 났고, 아직까지도 그때의 전율을 잊지 못한다\n약 50개의 팀과 200명 정도의 사람들이 해커톤에 참가했고 그 규모는 어마무시했다.\n우리 테이블을 도착하기 담요와, 해커톤 단체티, 보조배터리, 세면도구 등등이 비치되어있었고 바로 이것도 기념사진 찰칵\n해커톤의 모습을 여러개 담아봤다!\n저기 에어매트가 깔려있는 곳은 남자 수면실인데 밤되면 사람이 꽉차는 모습을 봤을때 마치 군대같다는 느낌을 받\u0026hellip; 크흠\n컵라면과 다과, 음료수까지 다양하게 준비되어 있었고 우리는 이곳이 천국이라고 생각했다.. 식고문을 당하기 전까지는\u0026hellip;. (이건 뒤에 나옴)\n아래 사진은 각 도의 부시장님들의 축사와 과기부의 개회사와 특강을 하는 모습을 찍었었다\n채점표에서는\n독창성 기술성 사업화가능성 적합성 을 주로 봤었고, 시제품까지 모두 만들어서 발표자료인 PPT로 넣어서 제출해야했다.\n굶기지 않겠다는 해커톤 대회.. 👉🏻 진짜로 가서 한 3키로는 쪄온 듯 하다\n아침, 점심, 저녁, 야식, 간식 모든 것을 다 챙겨주다보니 먹을걸 좋아하는 나도 힘들었다..\n처음에는 마냥 좋았는데, 2일차부터는 힘들더라\n먹은걸 정리해보자면\u0026hellip; 이렇다\n1일차\n저녁 : 반찬 겁나많은 도시락 야식 : 맘스터치 햄버거 2일차\n아침 : 샌드위치, 컵라면 점심 : 반찬 많은 도시락 저녁 : 반찬 많은 도시락 야식 : 치킨\u0026hellip; 3일차\n아침 : 샌드위치, 컵라면 점심 : 반찬 많은 도시락 먹는게 힘들어서 중간은 사진을 찍기도 힘들었다.. 깔깔\n이 정도면 먹으러 왔다고 해도 될 듯 ㅋ\n엄청난 식고문을 당하면서 개발하려니 식곤증 + 소화안됨 이러니 개발에 집중을 못하고있었음ㅋㅋㅋㅋ 거의 조련당함;\n근데 이렇게 많은 사람들과 함께 프로젝트하면서 식사도하고 느낌이 너무 재밌었당\n프로젝트 마무리 👉🏻 어느덧 3일차가 마무리되고 우리는 어찌저찌 고난과 역경을 버티며 프로젝트를 완성해나갔다.\n전체 영상을 다 보여줄 순 없지만, 이런 느낌으로 ChatGPT와 귀여운 캐릭터들로 자아탐구를 할 수 있는 앱을 만드는 것을 목표로 했다.\n수상 👉🏻 아쉽게도 우리 팀은 수상하지 못했다.\n발표는 5분 발표, 3분 질의응답으로 진행되었고, 시간이 지날시 마이크가 바로 꺼지게 되어 시간을 칼같이 지켰다.\n우리팀도 열심히 발표를 마쳤지만 심사위원들의 질의응답으로 인해 아직 부족한 점이 많다는 것을 알게 되었고, 강팀들이 많다는 것을 알게되었기에 인정할 수 밖에 없었다!\n같은 자유과제에서의 대상팀!! 우리 바로 뒤의 팀이였는데 발표도 너무 잘했다고 생각한다. 뇌파를 읽는 장치와 게임을 이용하여 멘탈케어 어플을 만든 것을 보았는데.. 너무 멋있었다.\n무려 과기부장관상\u0026hellip;\n우리도 저 단상을 오르길 기약하며 다시 한번 각오를 다졌다. 내년에는 꼭 상을 타봐야지\u0026hellip;!!\n후기 무박 3일간 프로젝트를 진행하면서 팀원들과 엄청 싸우진 않았지만, 다들 예민해져있는 상태였어서 약간의 말다툼이 있었던 것 같다.\n우리가 어떤 프로젝트 하는지도 모르는 상태에서 어떻게든 뭐라도 만들어보겠다고 발버둥치다가 서로가 싸우게 된 꼴이다.\n근데 나는 그렇게 생각한다. 우리의 아이템이 정확히 어떤 목적을 가지고 어떤 어플인지 소개할 수 있고, BM이 확실한지에 따라 우리가 뭘 만들고 싶은지도 알 수 있는 것 같다.\n막연히 이거 재미있겠다 해서 만들어도 괜찮겠지만 우리는 정말 사업을 하고싶은 팀이였으니까 사업적으로 부족한 부분에 대해서는 좀 아쉬웠다.\n아니 사실 많이 아쉬웠다.\n어쨌든 해커톤은 끝났고, 다시 또 도전을 할 것이기 때문에 그때는 좀 더 완벽해진 모습으로 대회에 참여했으면 하는 바램이다.\n그래도 이런 큰 대회를 처음으로 참가해보게 돼서 너무 좋은 경험을 한 것 같다. 개발자들이 한 곳에 모여 밤새 개발하는 모습들을 보면 서로가 서로의 동기부여가 되고 그 모습에 나도 열심히 개발하게 된 것 같다.\n내년에는 더 완벽해진 나와 팀으로 다시 한번 도전해서 꼭 수상을 하길..!\n💪🏻 화이팅\n","date":"2023-08-27T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-%EC%A0%9C-10%ED%9A%8C-%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD-sw%EC%9C%B5%ED%95%A9-%ED%95%B4%EC%BB%A4%ED%86%A4-%EB%8C%80%ED%9A%8C/SW_hackathon_hud583acf9098ff13dd72f57f968384565_138364_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/join-it-%EC%A0%9C-10%ED%9A%8C-%EB%8C%80%ED%95%9C%EB%AF%BC%EA%B5%AD-sw%EC%9C%B5%ED%95%A9-%ED%95%B4%EC%BB%A4%ED%86%A4-%EB%8C%80%ED%9A%8C/","title":"[Join IT] 제 10회 대한민국 SW융합 해커톤 대회!"},{"content":" Google I/O Extended Google I/O Extended Pangyo Event\nWhat\u0026rsquo;s I/O Extended I/O Extended는 GDG(Google Developers Group) 커뮤니티에 의해 전세계적으로 매년 개최되는 개발자 행사 중 하나이며, 보통 I/O Extended에서는 구글 기술과 관련된 세션, 코드랩, 스터디잼의 형태로 구성되며 진행됩니다.\nOrder to Event Welcome to Google I/O Extended!! 판교 테크원 건물 4F에서 진행을 하였고, NAVER의 여러 자회사들도 해당 건물에 위치해있어 기념으로 사진을 찍었다.\n그리고는 Google I/O Extended 행사장에 도착하여, GDG의 스티커와 티셔츠도 함께 제공받았다!\nGoogle I/O Connect by GDG Pangyo 조희주님 Point 👉🏻 기술적인 세션보다는 GDG 활동을 하면서 커넥트한 경험을 알려주셨다.\nGDSC 활동을 하면서 커뮤니티라는 느낌을 받은 적이 없는데, GDG는 커뮤니티적인 활동들을 많이 하시는 것 같다. 국내뿐만 아니라 해외의 GDG와도 커넥트를 하기위해 마이애미와 동아시아, 뉴질랜드사람들과도 만나셨다고 한다.\n또한, GDG분들과도 18년도부터 꾸준히 커뮤니케이션해왔다고 한다. 확실히 GDSC보다 조금 더 활발한 커뮤니티 그룹인 것 같아 추후에 들어가보고 싶은 마음이 생겼다.\nKeras core : changes and challenges by 래블업 신정규님 Point 👉🏻 AI에서 사용되는 근본인 Keras가 Keras core가 되어 나타난 이유와 역사\nAI에 대해 전무한 나에게는 너무나 어려운 내용이였다.. 그래도 Keras Core라는 것이 Tensor flow와 JAX 등을 함께 사용할 수 있는 커스텀 컴포넌트 멀티 프레임워크라는 점은 배웠다.\n금주부터 AI에 대한 교육을 받는데 어느정도 도움이 되었으면 좋겠다.\nAndroid Update 2023 by 레몬트리 권태환님 Point 👉🏻 Android 14버전의 변경이슈와 Android가 재미없는 이유\n곧 정식출시될 안드로이드 14는 정책에 관련된 변경점과 보안 세션에 관련된 내용만 주로 업데이트가 되었다고 하셨다. 예전에는 Android가 프리해서 개발자들이 좋아했다는데 점점 iOS랑 닮아가고 제한되는 부분들이 많아지면서 재미가 없다고 10년차 안드로이드 개발자분께서 말씀을 하셨\u0026hellip;ㅠ ㅋㅋ\n그리고, 새로운 기능들도 생겼다고 하셨는데 왜 생겼는지 모르겠다고 하셨닼ㅋㅋ\n대신 Compose에 대한 내용을 많이 설명해주셨다. Compose로 iOS, Android, Web, Android TV까지 사용할 수도 있다고(완벽히 호환되지는 X)하셨다. 그래서, 꾸준히 안드로이드를 하면 모든 플랫폼을 개발할 수 있는 기대를 가지고 계신다고 말씀해주셨다.\nReact18, 제로 번들을 향한 새로운 시작 by 당근마켓 이동근님 Point 👉🏻 React18의 게임체인저 RSC의 구조와 장점과 단점\n사실, 프론트엔드에 관심이 많았던 나는 이 세션이 가장 듣고싶었다. 자바스크립트가 많이 발전해오면서 SSR과 CSR, Universal SSR의 장점과 단점 그리고, Server Component인 RSC의 등장까지 말씀해주셨다.\nServer Component는 간단히 말하면 일부 컴포넌트는 Client에서 렌더링되고, 일부는 서버에서 컴포넌트가 렌더링돼서 Client로 보내주는 방식이다.\nRSC와 SSR의 차이점 👉🏻 일부가 서버에서 렌더링된다면 SSR이랑 같은거 아냐? 라고 생각할 수도 있지만, 서버라는 이름만 같지 전혀 다른 개념을 보여주고 있다.\nSSR의 경우는 html을 변환하고 변환된 것을 js로 다운받는 형태고 그 후 Hydration 작업과정을 거쳐 HTML 코드와 JS 코드를 서로 매칭시켜 동적인 웹사이트를 브라우저에 랜더링하는 형태지만, Server Component는 서버에서 동작하지만 실제로 바로 동작이 가능한 jsx 컴포넌트 단위로 내려줍니다.\n그렇기에 Hydration 작업이 필요없이도 바로바로 interaction이 가능하다고 말씀하셨다.\nSSR RSC 결국, 이러한 RSC는 더 나아가서 DB에 직접 접근하여 API요청 정보라든지 보안적인 부분에서 숨길 수 있게되고, 바로 인터렉션이 가능한 컴포넌트만 받아와서 사용할 수 있습니다. 즉, 렌더링에 필요한 번들이 필요없다는 Zero-bendle이 가능해진다는 의미겠죠.\n근데 마냥 RSC가 좋다고 할 수 있을까요? 서버 컴포넌트는 리액트의 심장인 Hooks를 사용하지 못합니다. 그래서 상태관리 또한 RSC에서는 어려워지죠.\n그리고, emotion이나 styled-component같은 css-in-js를 사용할 수 없습니다.\n또, RSC에 대한 reference가 별로 없습니다. 이제 react 18에 탑재된 만큼 아직 안정성과 효율성적인 측면에서도 보장을 못하고, 블로그를 작성하면서 찾아봐도 참고할 수 있는 것들이 별로 없었습니다.\n요약 RSC(React Server Component)는 SSR과 다르게 서버에서 바로 인터렉션이 가능한 컴포넌트 형태로 구성될 수 있으며, 일부는 Server Component 또 나머지 일부는 Client Component로 구현할 수 있습니다.\n장점\n제로 번들링이 가능 번들이 없으니 페이지 이동간 상태공유 렌더링 성능이 빨라짐 보안적인 측면에서 강화 단점\n리액트의 Hooks를 사용하지 못함 상태관리가 어려워짐 css-in-js를 사용하지 못함 후기 👉🏻 옵셔널 드레스코드가 하와이안 룩으로 되어있었는데, 몇몇분이 하와이안 룩으로 입고 오신 것을 봤다.. 존경스럽다\u0026hellip; 나도 슈퍼관종이였으면 입고갔을텐데 아쉽게도 슈퍼까진 아니였던걸로..🤭\nGDG에서 진행하는 행사인만큼 기대를 했고, 이벤트 상 순서에서는 세션이 종료 후 네트워킹 시간이 따로 배정되어있어있던걸 봤는데 세션이 끝나고 바로 종료가돼서 뭐지..? 싶었다. 오신 다른 개발자분들과도 함께 네트워킹해보고 싶었는데 ㅠㅠ..\n그래도 남아서 필요한 질의응답을 했고, 링크드인도 얻었다!\n친구랑 함께 기념사진을 찍고 마무리했다!\n관련자료 Tapas adhikary님의 React Server Components – How and Why You Should Use Them in Your Code ","date":"2023-08-19T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-google-i/o-extended-%ED%9B%84%EA%B8%B0/GDG-background_hu4934b5750425f5cf04750649578f9fb2_51097_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/join-it-google-i/o-extended-%ED%9B%84%EA%B8%B0/","title":"[Join IT] Google I/O Extended 후기"},{"content":"2023 INFCON 2023 이벤트 당첨 이벤트 결과일 INFCON 2023의 시간표 이벤트의 결과를 기다리며… 조마조마하고 있던 새벽에 딱… 문자가 왔었다\n두둥… 탁…!!!\n진짜… 너무 행복해서 바로 링크타고 들어가서 등록을 해버렸었지.. 그리고 어제 드디어 기다리고 기다리던 인프콘을 다녀왔다! 🎉\nINFCON 행사장 입성 처음에.. 삼성역에서 내리고 코엑스 입구를 잘 못찾아서 한참을 헤맸었는데 그냥 직진하다보니 어느새 코엑스에 도착.. 😅\n둑흔둑흔 거리는 내 맴 멈출수 없숴.. 두걔쟤~!\n등록 데스크에서 웰컴키트를 받고! 기념사진 찰칵\n근데.. 날씨가 너무 더웠음 사람들도 다들 부채질하고 난리\n그리고, 가드분들이 문 앞에 서계셔서 아무나 못들어오게 하셨음.. ㄷㄷ 무섭\n암튼! 인프콘 행사장에 입장!\n사람들도 무척 많았고, 부스도 꽤 있었다.. 현대차도 올줄이야..!!\n참가한 기업들도 되게 다양했다..!\n신기했던게 젯브레인이랑 몽고디비까지 올줄은 ㅋㅋㅋ 역시… 인프런 대단한 것 같다는 생각이 들었음..\n어쨌든! 간단히 부스를 둘러보고 10시가 되자 오프닝 키노트가 시작됐다.\n본격적인 INFCON 2023 시작 🎉 Opening Keynote 키야.. 내가 이걸 보기위해… 치열한 경쟁률을 뚫고 오다니 Form 미쳤다리\n인프런도 해마다 계속 성장하는 모습이 눈에 보이는 것 같아서 대단했다.\n벌써 118만 유저수를 기록했고(지금은 더 이상이겠지만), 인프런은 항상 유저들이 어떤 것을 원하는지 알고 발빠르게 움직이는 것 같았다.\n이제는 채용과 이력서, 강의까지 통합해서 사용할 수 있도록 만들겠다고 비전을 밝혔다.\n질문도 코드블럭을 넣어 더 편하게 질문할 수 있도록 만들고, 더 쉬운 이력서를 만들어주기 위해 릴랫에 힘을 많이 쓰고있는 것 같았다.\n앞으로 더 흥해서 쭉쭉 성장하는 통합 플랫폼이 되길 바란다!\n키노트가 종료되고 본격적으로 인프콘 행사가 시작되었는데, 먼저 내 시간표를 다시 잠깐 보자면, 아래와 같았다.\n꽤… 프론트엔드만을 지향하겠다는 의지가 강한 시간표였음..ㅋ\n아래부터는 세션별로 내용을 정리해봤습니다\n첫번째 세션 당신의 웹페이지는 몇 점인가요?: 라이트 하우스를 통한 프런트 성능개선\n👉🏻 시간표 공유하기 이벤트에서도 작성했었지만, Lighthouse를 좀 더 잘 사용해보고 원리를 파악하고 싶어 듣게되었다.\n로딩 성능을 최적화하기 위해서는 네트워크를 개선하거나 Redirect를 방지하거나 Cache를 적극적으로 사용하면 성능이 개선하면 된다\n요청하면서 대기하는 것들에 캐시를 적극적으로 사용하면 훨씬 빠르게 요청을 얻어올 수 있습니다.\n용량이 큰 이미지를 불러오기보다는 리소스를 압축해서 불러오면 더 빠르게 로딩성능을 향상시킬 수 있다.\n렌더링 성능, 리소스 로딩 성능이 끝나고 나서 받아온 리소스가 DOM에 그려지는 성능입니다. 이것을 최적화하기 위해서는 브라우저가 어떻게 그려지는지 알아야함!\nFCP, LCP 등과 같은 마크들을 생성하는데 특정 렌더링마다 paint시점을 말해주고있다. 이런 마크들의 수치를 확인하려면 개발자 도구 → 퍼포먼스 탭에서 확인할 수 있다.\n화면이 완전히 그려지기까지의 과정 FP → FCP → DCL → L → LCP\nLCP같은 경우 내가 보는 화면에서 가장 큰 콘텐츠를 렌더링하는 부분이기때문에 가장 중요한 시점이다.\nHTML 파싱을 여러번하지 않도록 하는게 중요하다. ⇒ img같은 것을 예로들면 img는 먼저 생성하지만, src를 추후에 삽입시키는 방향으로 하면 파싱을 1번밖에 하지 않는다.\n스타일 과정 Layout → Paint → Composite\n사용자 경험, 결국 웹서비스를 사용하는 사람이 서비스를 이용할 때 부드럽게 제공하냐 불편함을 겪냐가 중요하다\nCore Web Vitals는 사용자 경험을 개선하기 위한 지표 LCP, PID, CLS\nLighthouse를 통해 로딩성능과 렌더링성능과 사용자경험을 기준으로 해서 서비스에 대해 점수를 측정\n⇒ 측정 후 문제가 되는 것들을 리스트업해줘서 개선할 때 어떤 문제들이 있는지 파악할 수 있습니다.\n이미지 최적화만 해줘도 속도가 엄청 개선이 됩니다.\n두번째 세션 이때는 원래 Turborepo, Next.js, TypeScript를 이용한 프론트엔드 모노레포 적용기 를 듣고싶었지만, 첫번째 세션의 질의응답 시간이 길어져 참여하지 못하였습니다. ㅜㅜ 아숩\n[대신 질의응답 참여 인증샷!]\n세번째 세션 커뮤니케이션 잘하는 개발자의 4가지 습관\n👉🏻 토스에서 원하는 커뮤니케이션 잘하는 개발자란 무엇일까? 라는 궁금증때문에 듣게 된 세션\n좋은 개발자란 무엇인가?\n무작정 ‘안된다’라는 말 웬만해선 금지. ‘안된다’라는 말을 하기 보다는 이유가 뭘까? 요구사항을 받아들이기 위한 다른 방법은 없을까? 더 나은 방법은 없을까? 라는 생각을 가진 문제 해결형 개발자\n내가 이해한 바를 다시한번 말해보자. 상대방의 말을 듣고 내가 이해한 바를 공유함으로써 나중에 착오로 생길 더 큰 문제를 미리 해결할 수 있는 자기 생각을 공유하는 개발자\n말을 할 때 정리를 하는 습관을 들이자. 이렇게 정리해서 말할려는 노력을 하다보면 상대방 말을 더 잘 듣고 이해하게 돼서 내가 무슨말을 할지도 더 논리정연하게 설명할 수 있는 개발자\n질문 요청이나 요구사항을 들었을 때 조금만 참고 의도 사항을 물어보고 다른 방법은 없는지 생각하는 개발자\n네번째 세션 Hello, Interactive Developer: WebGL로 아트코딩 하기\n👉🏻 인터렉티브한 웹에 관심이 생기기 시작하여 듣고싶었다.\nWebGL(Web Graphics Library) : 웹 상에서 2D 및 3D 그래픽을 렌더링하기 위한 로우 레벨 JavaScript API이다. OepnGL ES 2.0을 기반으로 하고, HTML5의 \u0026lt;canvas\u0026gt; 요소를 사용한다.\n하지만 WebGL만을 사용하여 3D 요소를 구현하려면 상당히 복잡한 코드를 작성해야 하는데, Three.js는 이런 3D 요소의 처리를 도와 보다 직관적인 코드를 작성하도록 도와준다.\n즉, Three.js 는 웹페이지에 3D 객체를 쉽게 랜더링할 수 있도록 도와주는 Javascript 3D 라이브러리이며, WebGL 기술을 기반으로 랜더링과 카메라, 조명 등의 3D 프로그래밍 기술을 간단하게 사용할 수 있게 도와준다.\nThree.js를 사용하는 방법과 라이브러리를 활용하여 어떤 것들을 표현할 수 있는지 직접 영상을 제작하여 보여주시기도 했다.\n인터렉티브한 웹을 구현하기 위해서는 나의 생각과 예술적인 부분을 인터렉티브하게 표현할 수 있는 능력이 있어야한다고 생각했다. 하지만, 이과인 나는 영감을 얻기가 굉장히 힘들었다. 오기 전에 나를 퍼스널 브랜딩하기 위해 마인드맵을 하기도했고, 나의 정체성, 나는 무엇을 위해 살아가고 있는 것일까? 라는 철학적인 생각까지 해보기도 했지만 거기에서 어떤 부분을 강점으로 잡아야하는지 또, 나를 어떤 컨셉으로 표현할건지 등등 너무 어려웠다… 역시 영강을 통해 창의적인 생각을 하는건 쉽지 않다고 느꼈음..\n다섯번째 세션 👉🏻 이때 또한, 네번째 세션의 질의응답을 하다보니 늦어져 세션을 듣지 못했다. 그래서 남는 시간에 부스 방문과 스탬프를 많이 찍었다.\n여섯번째 세션 주니어 프론트엔드 엔지니어의 성과 및 역량 향상을 위한 실전 가이드\n👉🏻 주니어 프론트엔드 엔지니어로써 어떻게 좋은 시니어로 성장할 수 있을지 듣고싶었다.\n이 내용은 사실 주니어보다는 시니어분들이 들었으면 좋겠다는 생각이 들었다. 주니어들이 듣기에는 조금 힘든 내용이였다. 기술적으로 접근한다기보다는 철학적으로 생각을 해야되는 부분들이 많았고, 경험을 통해 얻을 수 있을 것 같은 내용이였다. 네트워킹 파티 🫶🏻 👉🏻 여러 사람들이랑 만나보면서 어떤 일을 하고계시는지와 실무에서의 프론트엔드분들이 주로 어떤 업무를 맡고계시는지 궁금해서 참여해보고싶었다.\n[네트워킹과 귀여운 토끼 캐릭터와 인증샷]\n시간이 생각보다 짧았다 ㅠㅠ 많은 사람들과 얘기를 하진 못했지만 현대자동차, 요기요, 우아한형제들, 토스 의 실무자분들과 커피챗을 하면서 도움을 많이 얻었다. 나는 아직 학생이라 명함을 드리진 못했지만.. ㅎ 실무자분들의 명함을 받아서 좋았다..!! 언젠가 도움이 생기면 연락달라고 하셔서 확실히 IT쪽이 이런 활동들이 활발해서 더 좋은 것 같다\n많은 실무자분들이 말씀하시길 신입은 사실 많은 기술을 요하기보다는 학부생때 기초를 더 탄탄하게 만들고 가는게 좋다고 많이들 조언해주셨다. 그래서, 안그래도 기초를 중요시하는 나에게 지금 내가 가고있는 길이 맞는 길인지 의심했던 나에게 확신을 주셨다.\n스탬프와 보상 👉🏻 혼자갔지만, 정말 열심히 돌아다녔닼ㅋㅋㅋ 혼자와서 쓸쓸하긴 했다만 그래두 와서 뽕을 뽑겠다는 느낌으로 활보했다.\n나의 아름다운 스탬프 투어표를 보라! 🤣\n그리고 거기에서 받은 상품들!! 티셔츠, 스티커, 유리컵, 부채, 보조배터리, 무선충전기, 부채, 수건 등등… 지금보니 엄청많네\n첫 인프콘 경험기 처음 가보는 큰 컨퍼런스인 INFCON! 첫 느낌이 너무 좋았다. 열심히 살고 있는 나에게 더 많은 동기 부여가 되었고, 더 열심히 살아야겠다는 생각이 들었다. 이번에 두번째로 열린 인프런 컨퍼런스라는데 두번째치고는 너무 완벽한 컨퍼런스 아니였나..? 싶다. 그래서 추후에는 얼마나 더 큰 규모로 성장해서 열릴지 기대가 되고, 그럴때마다 한층 더 성장한 내가 그 현장에 참가하면 같이 성장해나가는 느낌이 받지 않을까?\n추후에도 열릴 INFCON에 참가했으면 좋겠다\u0026hellip; 인프런 화이팅 🙌🏻!!\n","date":"2023-08-16T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-2023-infcon/8-16-thumb_hudfaab8ee98e5f94773b8a3aab54bc50a_6083552_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/join-it-2023-infcon/","title":"[Join IT] 💫 2023 INFCON 💫"},{"content":"들어가며 React 프로젝트를 처음 시작하게 될 때, 저처럼 프론트엔드 초보자인 분들은 npm install만 하고나서 어떻게 해야할지 모를 때가 있을 것 같습니다.\n최근에도, 프로젝트를 처음으로 시작하는데 어떤 기술을 써야할지 프로젝트 셋팅은 어떻게 해야할지 자꾸 까먹게되서 그냥 이참에 프로젝트 초기 셋팅하는 법을 확실하게 알고, 또 추후에 React + Typescript로 프로젝트를 진행하게 될 때 좀 더 빠르게 초기 설정을 하기위해 이 포스트를 작성하려합니다.\n사실, 프로젝트에서 기획에 맞는 어떤 기술을 사용할거냐부터 정하는게 우선이긴 하지만 우리는 React + Typescript로 정했다는 가정하에 진행을 하려합니다.\n필요하면 어떤 서비스를 하게될 때 어떤 기술을 사용할지 파악하는 글도 추후에 올려볼려고합니다.\n어쨋든, 서론이 길었는데 한줄로 요약하자면 프로젝트 초기설정을 쉽고 빠르게 하기위함이 이 글의 목표입니다.\n프로젝트 초기 환경 셋팅 본인이 가지고 있는 환경은 맥OS이나 추후에 윈도우에서 충분히 쉽게 사용할 수 있도록 윈도우 환경, 맥 환경 둘 다 셋팅할 수 있는 방법을 적을 것입니다.\n윈도우 개발 환경 설정 React 프로젝트를 사용하기 위해서는 반드시 노드 설치가 필요합니다\n초콜리티 설치 초콜리티(Chocolatey)는 윈도우에서 패키지를 설치하고 관리할 수 있는 윈도우용 패키지 관리자입니다 맥에서의 Homebrew와 같은 역할을 한다고 보시면 됩니다\n긴말 말고, 바로 아래 링크를 통해 초콜리티 다운로드를 합니다.\nhttps://chocolatey.org/install\n그럼 아래와 같은 페이지가 뜰 텐데, 여기서 Now run the following command에 있는 명령어를 복사하여\n명령 프롬프트(cmd)또는 파워셸(PowerShell)을 관리자 권한으로 실행한 후, 위에서 복사한 코드를 붙여넣기한다.\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 설치가 완료되면 다음 명령어를 실행시켜 초콜리티가 잘 설치됐는지 확인합니다\n1 choco -version 문제없이 설치되었다면 버전이 뜨게 될 것입니다.\n노드 설치 초콜리티가 설치되었으면 이제 노드를 설치해보도록 하겠습니다.\n리액트는 자바스크립트 라이브러리로, 프로젝트를 생성하고 개발에 필요한 외부 라이브러리를 사용할 때에 노드 패키지(Node Package)를 이용하게 됩니다.\n따라서 리액트로 개발하기 위해서는 노드를 꼭 설치해야합니다.\n윈도우의 명령 프롬프트를 관리자 권한으로 실행시킨 후 다음 명령어를 실행시켜 노드를 설치합니다.\n1 choco install -y nodejs.install 설치가 완료되면 명령프롬프트를 다시 실행시킨 후 다음 명령어를 실행시키면 노드의 버전이 나오면서 노드가 잘 설치되었는지 확인할 수 있습니다\n1 node --version 맥 개발 환경 설정 홈브루 설치 홈브루(Homebrew)는 패키지를 설치하고 관리할 수 있는 맥용 패키지 관리자입니다.\n우선 아래 링크를 통해서 맥에 홈브루를 설치합니다.\nhttps://brew.sh/index_ko (설치법은 해당 링크에 잘 설명되어있음)\n노드 설치 터미널을 열고 다음 명령어를 실행하여 노드를 설치합니다\n1 brew install node 설치가 완료되면 명령어로 노드가 제대로 설치되었는지 확인한다\n1 node -v 노드를 설치하면, 노드의 패키지를 관리하는 노드 패키지 매니저인 npm(Node Package Manager)도 같이 설치된다. 이것도 잘 설치되어있는지 확인한다.\n1 npm -v 리액트 프로젝트 시작 리액트를 사용하여 프로젝트를 시작하는 방법은 다양합니다.\n스크립트 태그 추가 Webpack이나 Babel을 설정하여 개발 CRA(create-react-app) Next.JS 프레임워크 설치 우리는 CRA방식으로 진행을 할 것이지만 다른 것들은 어떻게 다른지 간단하게 살펴보면 좋을 것이다.\n스크립트 태그 추가 리액트는 자바스크립트 라이브러리이므로 jQuery와 같은 보통의 자바스크립트의 사용방법과 동일하게 스크립트 태그를 추가하여 사용할 수 있습니다\n1 2 3 4 5 6 \u0026lt;body\u0026gt; ... \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; ... \u0026lt;script async src=\u0026#34;https://unpkg.com/lodash\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 기존에 그냥 JS로만 작성되어있는 웹서비스인 경우에는 빠르게 리액트로 시작할 수 있는 방법이지만, 고려해야할 사항이 많다.\nWebpack이나 Babel을 설정하여 개발 크로스 브라우징 문제와 최신 ECMAScript, Typescript등을 사용하여 리액트 프로젝트를 진행하기 위해서는 Webpack, Babel을 설정하여 개발을 할 수 있습니다.\nhttps://goo-gy.github.io/2021-12-31-webpack-react (goo-gy님의 Webpack을 이용한 React개발)\n하지만, Webpack이나 Babel을 잘 알아야하기때문에 초보자들에게는 큰 어려움이 있습니다.\nCRA(create-react-app) Webpack이나 Babel을 설정하여 개발하는 방법에 대해 어려움을 인지한 페이스북이 create-react-app이라는 CLI(Command Line Interface) 툴을 만들어서 배포했습니다.\nhttps://create-react-app.dev/\n보편적으로 제일 많이 사용하기도 하고, 이 툴을 사용하면 간단하게 리액트 프로젝트를 생성하고 개발할 수 있습니다\nNext.JS 프레임워크 이건 React만을 사용하는게 아닌 더 많은 기능을 제공하는 프레임워크인 만큼 Next.js만이 가진 기능과 고유한 방법들이 있기때문에 React를 어느정도 알고난 후 SSR과 router을 사용하고싶다하면 그때 공부해도 괜찮을 것 같다.\ncreate-react-app 그러면 create-react-app으로 리액트를 개발하는 방법에 대해 알아보자\ncreate-react-app 설치 다음 명령어를 실행하여 create-react-app을 설치합니다.\n1 npm install -g create-react-app 다음 명령어를 사용하여 문제없이 설치되었는지 확인합니다\n1 npx create-react-app --version 여기서 헷갈리면 안되는 점! 👉🏻 npm은 패키지를 설치할 때 사용하는 명령어이고, npx는 npm을 통해 설치한 패키지를 실행할 때 사용하는 명령어\ncreate-react-app으로 프로젝트 생성 및 실행 다음 명령어를 통해 React 프로젝트를 생성해봅시다.\n1 npx create-react-app my-app 여기까지는 일반적인 React 프로젝트를 생성하는 방법이지만, 우리는 더 Typescript와 실무에서 사용되는 Emotion, prettier까지 설정을 해볼 것입니다.\nReact 프로젝트를 Typescript로 설정 React프로젝트를 Typescript로 설정하는 방법에는 2가지 존재합니다\n기존 React프로젝트에서 Typescript를 설정 CRA로 프로젝트 생성과 동시에 Typescript를 설정 기존 React프로젝트에서 Typescript를 설정 이미 생성되어있는 리액트 프로젝트에 타입스크립트를 적용하기 위해서는 타입스크립트 라이브러리와 리액트의 타입이 정의된 타입 정의 파일을 설치할 필요가 있습니다.\ntypescript : 타입스크립트 라이브러리 @types/node : 자바스크립트 런타임인 노드의 타입이 정의된 타입 정의 파일 @types/react : 리액트의 타입이 정의된 타입 정의 파일 @types/react-dom : react-dom의 타입이 정의된 타입 정의 파일 해당 프로젝트의 터미널에서 다음 명령어를 실행시킵니다.\n1 npm install --save-dev typescript @types/node @types/react @types/react-dom 설치가 완료되었다면 해당 프로젝트의 루트 폴더에서 tsconfig.json파일을 생성하고 내용을 다음과 같이 수정합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es5\u0026#34;, \u0026#34;lib\u0026#34;: [\u0026#34;dom\u0026#34;, \u0026#34;dom.iterable\u0026#34;, \u0026#34;esnext\u0026#34;], \u0026#34;allowJs\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;allowSyntheticDefaultImports\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;noFallthroughCasesInSwitch\u0026#34;: true, \u0026#34;module\u0026#34;: \u0026#34;esnext\u0026#34;, \u0026#34;moduleResolution\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;resolveJsonModule\u0026#34;: true, \u0026#34;isolatedModules\u0026#34;: true, \u0026#34;noEmit\u0026#34;: true, \u0026#34;jsx\u0026#34;: \u0026#34;react-jsx\u0026#34; }, \u0026#34;include\u0026#34;: [\u0026#34;src\u0026#34;] } 위와 같이 작성했다면 자바스크립트 파일들을 타입스크립트 파일로 변경합니다.\n./src/App.js 👉🏻 ./src/App.tsx ./src/App.test.js 👉🏻 ./src/App.test.tsx ./src/index.js 👉🏻 ./src/index.tsx ./src/reportWebVitals.js 👉🏻 ./src/reportWebVitals.ts ./src/setupTest.js 👉🏻 ./src/setupTest/ts 다음으로는 기존의 자바스크립트 코드를 타입스크립트를 사용하여 변경해야합니다. 우선 svg 파일을 타입스크립트에서 불러올 수 있게 하기위해 ./src/custom.d.ts파일을 생성하고 다음과 같이 수정합니다.\n1 2 3 4 5 6 declare module \u0026#34;*.svg\u0026#34; { export const ReactComponent: React.FunctionComponent\u0026lt;React.SVGProps\u0026lt;SVGSVGElement\u0026gt; \u0026amp; { title?: string }\u0026gt;; const src: string; export default src; } 여기서 생성하는 d.ts 파일은 타입 정의 파일로 타입스크립트가 인식하지 못하는 타입이지만, 타입스크립트 안에서 사용할 특정 타입들을 정의할 때 사용합니다.\n그리고 ./src/reportWebVitals.ts 파일을 열고 다음과 같이 수정합니다.\n1 2 3 4 5 6 7 import { ReportHandler } from \u0026#34;web-vitals\u0026#34;; const reportWebVitals = (onPerfEntry?: ReportHandler) =\u0026gt; { ... }; export default reportWebVitals; 이렇게 모든 설정이 끝났다면 리액트 프로젝트를 실행시켜 페이지가 잘 표시되는지 확인해보면 됩니다!\nCRA로 프로젝트 생성과 동시에 Typescript를 설정 (template 사용) create-react-app에서 제공하는 템플릿 옵션에서 typescript를 적용시켜 생성시킬수도 있습니다.\n다음 명령어를 사용해서 새로운 타입스크립트 리액트 프로젝트를 생성해봅시다\n1 npx create-react-app my-app --template=typescript 이렇게 template 옵션으로 사용하면 전에 기존-react프로젝트에서-typescript를-설정에서 했던 것과 동일하게 적용이 된 것을 확인할 수 있고 더 쉽고 빠르게 프로젝트를 생성할 수 있습니다.\n스타일링 리액트는 웹 어플리케이션 개발에 사용하는 라이브러리이므로 스타일링은 물론 웹 페이지 개발과 동일하게 CSS를 사용할 수 있습니다.\n자바스크립트 안에서 스타일링 할 수 있는 CSS-in-JS기법을 사용하여 emotion으로 함수형 스타일링도 많이 적용하는 것을 볼 수 있습니다. (styled-components도 많이 사용하고있다고 하니 관심있으면 찾아보시길)\n보통 리액트는 컴포넌트를 기반으로 개발되기에 CSS파일을 갖는 형식으로 스타일을 관리하게 됩니다. 하지만 이렇게 각각의 컴포넌트에서 CSS를 분리하여 관리하다보면 CSS의 클래스명이 중복되어 의도치 않은 스타일이 적용될 수도 있습니다.\nCSS-in-JS의 장점 이런 문제를 해결하고자 CSS-in-JS라는 방법론이 탄생했는데, 이런 방법으로 사용하면 어떤 장점이 있는지 살펴보자\n클래스명 버그 해결\n보통 CSS에 클래스명을 생성하고 스타일을 작성한 후 해당 이름을 HTML 태그에 적용함으로써 스타일을 적용합니다. 하지만 이런 방식은 클래스명의 중복, 겹침 또는 오타 같은 문제가 발생할 수도 있기에 CSS-in-JS는 스타일을 컴포넌트에 직접 적용함으로써 이런 문제를 해결하고 있다\n보다 쉬운 CSS 관리\nCSS-in-JS는 모든 스타일이 특정 컴포넌트에 연결되기 때문에 보다 명확히 사용되는 스타일을 알 수 있으며 불필요한 스타일을 쉽게 제거할 수 있다\n간단한 동적 스타일 적용\n일반적으로 동적 스타일을 위해 여러 클래스를 생성하고 해당 클래스가 특정 조건일 때에 추가되도록 하는데, 이런 방식은 코드를 복잡하게 하며 깔끔하지 않지만, CSS-in-JS는 여러 클래스를 만들 필요가 없으며 컴포넌트의 상태에 따라 쉽고 직관적으로 동적 스타일을 줄 수 있다\nCSS 자동 구성\nstyled-components 또는 Emotion을 사용하면 페이지에 렌더링되는 컴포넌트를 추적하여 해당 스타일을 완전히 자동으로 추가합니다. 또한 코드 분할(Code Splitting)시 사용자가 필요한 최소한의 코드를 자동으로 추가한다\nEmotion 스타일링 적용 Emotion으로 스타일링을 하려면 먼저 현재 프로젝트의 터미널로 들어가 다음 명령어를 입력한다\n1 npm install --save @emotion/react @emotion/styled 그러면 간단하게 App.tsx파일을 CSS-in-JS방식으로 수정한다하면\n1 2 3 4 5 6 7 8 9 10 11 import \u0026#34;./App.css\u0026#34;; function App() { return ( \u0026lt;div className=\u0026#34;App\u0026#34;\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt;...\u0026lt;/header\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; 위와 같은 코드를 아래처럼 변경할 수 있을 것이다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import \u0026#34;./App.css\u0026#34;; import styled from \u0026#34;@emotion/styled\u0026#34;; const Container = styled.div` text-align: center; `; function App() { return ( \u0026lt;Container\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt;...\u0026lt;/header\u0026gt; \u0026lt;/Container\u0026gt; ); } export default App; Emotion을 사용하여 리액트 컴포넌트를 생성하기 위해서는 styled.[HTML태그]형식과 자바스크립트의 템플릿 리터럴(``)을 사용하면 쉽게 컴포넌트를 스타일링 할 수 있다.\n동적인 이미지인 img태그도 아래처럼 변경할 수 있다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import styled from \u0026#34;@emotion/styled\u0026#34;; const AppLogo = styled.img` height: 40vmin; pointer-events: none; @media (prefers-reduced-motion: no-preference) { animation: App-logo-spin infinite 20s linear; } `; const AppLink = styled.a` color: #61dafb; `; function App() { return ( \u0026lt;Container\u0026gt; \u0026lt;header className=\u0026#34;App-header\u0026#34;\u0026gt; \u0026lt;AppLogo src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;p\u0026gt; Edit \u0026lt;code\u0026gt;src/App.tsx\u0026lt;/code\u0026gt; and save to reload. \u0026lt;/p\u0026gt; \u0026lt;link href=\u0026#34;https://reactjs.org\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34; \u0026gt; Learn React \u0026lt;/link\u0026gt; \u0026lt;/header\u0026gt; \u0026lt;/Container\u0026gt; ); } export default App; 여기서, 중요한 점은 @media를 리터럴 안에 적용시킬 수 있다는 점과 원래 css였다면 .App-logo라는 클래스명안에 animation을 적용시켜야했다면\n1 2 3 4 5 @media (prefers-reduced-motion: no-preference) { .App-logo { animation: App-logo-spin infinite 20s linear; } } Emotion으로 제작한 컴포넌트는 해당 컴포넌트가 직접 애니메이션을 수행하므로 클래스명을 특별히 지정하지 않고 직접 애니메이션을 사용하면 된다는 것\n1 2 3 4 5 6 7 8 const AppLogo = styled.img` height: 40vmin; pointer-events: none; @media (prefers-reduced-motion: no-preference) { animation: App-logo-spin infinite 20s linear; } `; 또한, keyframes를 사용하여 로고 이미지에서 사용할 회전 애니메이션을 따로 선언하여 변수로 사용할 수도 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import styled from \u0026#34;@emotion/styled\u0026#34;; import { keyframes } from \u0026#34;@emotion/react\u0026#34;; const spinAnimation = keyframes` from { transform: rotate(0deg); } to { transform: rotate(360deg); } `; const AppLogo = styled.img` height: 40vmin; pointer-events: none; @media (prefers-reduced-motion: no-preference) { animation: ${spinAnimation} infinite 20s linear; } `; Emotion으로 제작한 컴포넌트는 자바스크립트의 템플릿 리터럴을 사용하기 때문에 문자열 중간에 자바스크립트 변수를 사용할 수도 있다.\n이처럼 자주 사용되는 애니메이션은 Emotion의 keyframes를 사용하여 미리 정의하고, 필요한 부분에서 불러와 사용하면 된다.\n모든 컴포넌트는 Emotion으로 바꾸면 다음과 같다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 import logo from \u0026#34;./logo.svg\u0026#34;; import \u0026#34;./App.css\u0026#34;; import styled from \u0026#34;@emotion/styled\u0026#34;; import { keyframes } from \u0026#34;@emotion/react\u0026#34;; const Container = styled.div` text-align: center; `; const Header = styled.header` background-color: #282c34; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: calc(10px + 2vmin); color: white; `; const spinAnimation = keyframes` from { transform: rotate(0deg); } to { transform: rotate(360deg); } `; const AppLogo = styled.img` height: 40vmin; pointer-events: none; @media (prefers-reduced-motion: no-preference) { animation: ${spinAnimation} infinite 20s linear; } `; const AppLink = styled.a` color: #61dafb; `; function App() { return ( \u0026lt;Container\u0026gt; \u0026lt;Header\u0026gt; \u0026lt;AppLogo src={logo} alt=\u0026#34;logo\u0026#34; /\u0026gt; \u0026lt;p\u0026gt; Edit \u0026lt;code\u0026gt;src/App.tsx\u0026lt;/code\u0026gt; and save to reload. \u0026lt;/p\u0026gt; \u0026lt;AppLink href=\u0026#34;https://reactjs.org\u0026#34; target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener noreferrer\u0026#34; \u0026gt; Learn React \u0026lt;/AppLink\u0026gt; \u0026lt;/Header\u0026gt; \u0026lt;/Container\u0026gt; ); } export default App; 절대경로로 컴포넌트 추가 리액트 프로젝트 개발 시 우리는 수많은 리액트 컴포넌트를 제작하고, 제작한 컴포넌트를 블록을 조합하듯 페이지를 제작하게된다. 이때 리액트 컴포넌트는 보통 상대경로(import Button from \u0026lsquo;./../../../Button\u0026rsquo;)를 사용하여 불러와 사용하게 된다.\n이는 컴포넌트의 개수가 적고 폴더 구조가 복잡하지 않을 경우에는 큰 문제가 없다.\n하지만 프로젝트가 커지고 수많은 컴포넌트들이 추가되면서 프로젝트의 폴더 구조가 복잡해지면, 상대 경로 추가 방식은 어떤 경로를 지정하고 있는지 명확하게 파악하기 어렵고 필요한 컴포넌트를 추가할 때에 경로를 추가하기 어렵다.\n이런 문제는 타입스크립트의 설정으로 간단히 해결할 수 있다.\n프로젝트에서 tsconfig.json파일을 열고 바음과 같이 baseUrl옵션을 추가한다.\n1 2 3 4 5 6 7 8 { \u0026#34;compilerOptions\u0026#34;: { ... \u0026#34;jsx\u0026#34;: \u0026#34;react-jsx\u0026#34;, \u0026#34;baseUrl\u0026#34;: \u0026#34;src\u0026#34; }, ... } 그러면 기존에 상대경로로 import했던 컴포넌트를\n1 import App from \u0026#34;./components/App\u0026#34;; 아래처럼 절대경로로 사용할 수 있게된다.\n1 import App from \u0026#34;components/App\u0026#34;; 지금은 폴더구조가 복잡하지 않아 필요성이 느껴지지 않겠지만, 실무에서 복잡한 프로젝트를 다루게된다면 이런 방식이 왜 필요한지 알게될 것이다.\nPrettier Prettier는 코드 포맷터(Code formatter)로 Javascript, CSS, JSON 등을 지원한다. Prettier는 미리 약속한 코드 스타일에 맞춰 자동으로 코드의 형식을 수정해주는 도구로, 협업시 여러 개발자들의 코드 스타일을 맞추는데 큰 도움을 준다.\nPrettier 설치 Prettier를 적용시킬 프로젝트의 터미널을 열고 다음 명령어로 Prettier를 설치한다\n1 npm install --save-dev prettier Prettier 설정 해당 프로젝트의 루트 폴더에 .prettierrc.js 파일을 생성하고 다음과 같이 수정하여 Prettier를 설정합니다.\n1 2 3 4 5 module.exports = { singleQuote: true, trailingComma: \u0026#34;all\u0026#34;, printWidth: 100, }; 여기서 설정한 내용은 다음과 같다\nsingleQuote : 싱글쿼트(\u0026rsquo;)를 주로 사용하도록 설정 trailingComma : 콤마(,)를 추가할 수 있다면, 콤마를 추가하도록 설정 printWidth : 한 줄에 작성할 수 있는 최대 코드 문자 수를 설정 Prettier 실행 설정이 완료되었다면, package.json파일에서 Prettier를 실행하는 스크립트를 작성한다.\n아래처럼 \u0026ldquo;format\u0026quot;과 \u0026ldquo;format:fix\u0026quot;라는 스크립트를 추가한다.\n1 2 3 4 5 6 7 8 9 10 { ... \u0026#34;scripts\u0026#34;: { ... \u0026#34;eject\u0026#34;: \u0026#34;react-scripts eject\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;prettier --check ./src\u0026#34;, \u0026#34;format:fix\u0026#34;: \u0026#34;prettier --write ./src\u0026#34; }, ... } format : Prettier를 check 옵션과 함께 실행하여 우리가 설정한 내용에 위반되는 내용이 있는지 검사하는 스크립트 format:fix : Prettier를 write 옵션과 함께 사용하여 잘못된 내용을 설정한 내용에 맞게 자동으로 수정해주는 스크립트 자 이제 Prettier를 실행해보자\n해당 프로젝트에 .prettierrc.js파일에 맞는 format을 지키고 있는지 검사하려면 해당 프로젝트 터미널에 다음과 같이 입력한다\n1 npm run format 그러면 다음과 같은 결과를 확인할 수 있다 결과 내용을 보면 4가지의 파일에서 prettier 규칙에 위반하는 것을 확인할 수 있다.\n이제 위반한 내용을 쉽게 수정하게 만들려면 다음 명령어를 실행시키면 된다.\n1 npm run format:fix 그리고 나서 다시 npm run format을 해보면 문제가 없다는 것을 확인할 수 있다\nESLint ESLint는 ES(ECMAScript)와 Lint(에러 코드 표식)의 합성어로, 자바스크립트의 코드를 분석하고 잠재적인 오류나 버그를 찾는데 도움을 주는 정적 분석 툴이다\n여러 개발자들이 하나의 소스코드를 수정하는 협업 환경에서 ESLint는 소스 코드를 분석하고 오류나 버그의 가능성을 지적하거나 소스 코드의 스타일을 일관성 있게 관리해주기 때문에 Prettier와 함께 자주 사용된다\nESLint 설치 ESLint를 설치할 프로젝트의 터미널을 열고 다음과 같이 ESLint를 설치한다\n1 npm install eslint --save-dev ESLint 설정 설치가 됐다면 다음 명령어를 실행하여 ESLint를 초기화하자\n1 npx eslint --init 그리고나서는 7~8개의 질문을 할건데\nESLint를 설정하기 위해 필요한 라이브러리를 설치할 것인가? y 문제점을 찾는 것과 잘못된 점을 고치는 스크립트를 따로 작성할 것인가? To check syntax and find problem 프로젝트에서 모듈을 추가할 때 어떤 방식을 선택할건지? Javascript 어떤 프로젝트에서 사용할건지? React Typescript를 사용하는지? Yes 어떤 환경에서 실행되는지? Browser 설정 파일의 포맷을 어떤 형식으로 저장할건지? Javascript 지금까지 설정한 내용으로 설치를 진행할건지? Yes 어떤 패키지 매니저로 설치하는걸 원하는지? npm 그러면 eslintrc.js파일이 자동으로 생성되고 안에는 다음과 같은 내용이 추가된다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 module.exports = { env: { browser: true, es2021: true, }, extends: [ \u0026#34;eslint:recommended\u0026#34;, \u0026#34;plugin:@typescript-eslint/recommended\u0026#34;, \u0026#34;plugin:react/recommended\u0026#34;, ], overrides: [ { env: { node: true, }, files: [\u0026#34;.eslintrc.{js,cjs}\u0026#34;], parserOptions: { sourceType: \u0026#34;script\u0026#34;, }, }, ], parser: \u0026#34;@typescript-eslint/parser\u0026#34;, parserOptions: { ecmaVersion: \u0026#34;latest\u0026#34;, sourceType: \u0026#34;module\u0026#34;, }, plugins: [\u0026#34;@typescript-eslint\u0026#34;, \u0026#34;react\u0026#34;], rules: {}, }; 만약 ESLint와 타입스크립트를 검사하는 룰을 변경하고싶다면, rules 옵션에 필요한 내용을 추가하면 된다.\n마지막으로, ESLint에 리액트 버전을 알려줄 필요가 있으며 react/react-in-jsx-scope 규칙의 사용을 중지시킬 필요가 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //eslintrc.js module.exports = { settings: { react: { version: \u0026#34;detect\u0026#34;, }, }, env: { ... }, ... rules: { \u0026#34;react/react-in-jsx-scope\u0026#34;: \u0026#34;off\u0026#34;, }, }; react/react-in-jsx-scope 규칙은 jsx파일에서 import React from \u0026lsquo;react\u0026rsquo;를 항상 사용하도록 하는 규칙이지만 리액트의 버전 17부터 import React from \u0026lsquo;react\u0026rsquo;를 할 필요가 없어졌기 때문에 이 규칙을 사용하지 않도록 할 필요가 있다.\n자세한 내용은 아래 공식 문서를 참고하면 된다\nreact/react-in-jsx-scope : https://github.com/jsx-eslint/eslint-plugin-react/blob/master/docs/rules/react-in-jsx-scope.md\nRemoving Unused React imports : https://legacy.reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html#removing-unused-react-imports\n이제 설정한 ESLint를 사용하여 잠재적인 오류나 버그를 찾기 위한 실행 스크립트를 만들어보자. package.json에서 ESLint 실행 스크립트를 추가하자\n1 2 3 4 5 6 7 8 9 { ... \u0026#34;scripts\u0026#34;: { ... \u0026#34;lint\u0026#34;: \u0026#34;eslint ./src\u0026#34;, \u0026#34;lint:fix\u0026#34;: \u0026#34;eslint --fix ./src\u0026#34; }, ... } ESLint 실행 다음과 같이 명령어를 실행하면 ESLint로 소스코드를 검사해볼 수 있다\n1 npm run lint 현재는 오류가 발생하지 않았지만, eslint로 인한 규칙 위반시 npm run lint:fix 명령어를 실행하면 된다.\n요약 우리가 배운 내용을 간단하게 요약하면 다음과 같다\nCRA에서 template으로 Typescript 간단하게 적용시키기 Emotion으로 CSS-in-JS 함수형 스타일링하여 컴포넌트 제작하기 소스코드의 스타일을 맞추거나 잠재적인 오류, 버그를 방지하기 위해 실무에서 자주 사용되는 Prettier와 ESLint 적용 방법 실무에서 다른 개발자들과 협업하기 위해서는 꼭 필요하고 자주 사용된다고 하니 알아놓으면 좋을 것 같고, 앞으로 프로젝트 초기설정을 할 때에는 위에서 배운 내용을 토대로 쉽게 셋팅할 수 있을 것 같다.\n","date":"2023-07-31T00:00:00Z","image":"https://myeongcode.github.io/p/react-react--typescript-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%85%8B%ED%8C%85%EB%B2%95/react-logo_hua3ebe5898a4e39adc84559693d29cf1f_231564_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/react-react--typescript-%EC%8B%A4%EB%AC%B4%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EC%85%8B%ED%8C%85%EB%B2%95/","title":"[React] React + Typescript 실무에서 사용하는 프로젝트 셋팅법!"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* [programmers / 양꼬치] n\tk\tresult 10\t3\t124,000 64\t6\t768,000 */ function solution(n, k) { let lambSkewers = 12000; let drink = 2000; let serviceDrink = parseInt(n / 10); lambSkewers *= n; k -= serviceDrink; drink *= k; const answer = lambSkewers + drink; return answer; } 단순히 10인분 당 음료수 1개가 서비스니까 인분 당 서비스 개수를 구하고, k(먹은 음료수 개수)에서 serviceDrink(받을 수 있는 음료수 서비스 개수)를 뺀 값을 drink(실제 계산해야하는 값)에 넣어주면 끝\n완료 ✅\n","date":"2023-07-21T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%96%91%EA%BC%AC%EC%B9%98/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%96%91%EA%BC%AC%EC%B9%98/","title":"[Programmers] 양꼬치"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* [programmers / 각도기] angle\tresult 70\t1 91\t3 180\t4 */ function solution(angle) { const angleResult = angle / 90; let answer; if (angleResult \u0026lt; 1) answer = 1; else if (angleResult === 1) answer = 2; else if (angleResult \u0026lt; 2) answer = 3; else answer = 4; return answer; } 더 간단하게 코드를 줄일 수 있을 것 같은데.. 뭔가 아쉽다\u0026hellip; 다른 사람들은 어떻게했을까?\n[다른사람의 풀이]\n1 2 3 function solution(angle) { return [0, 90, 91, 180].filter((x) =\u0026gt; angle \u0026gt;= x).length; } 와,,,, 이렇게 하는 사람도 있네 미쳤다\n어쨋든 뭐,,, 정답!\n완료 ✅\n","date":"2023-07-20T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EA%B0%81%EB%8F%84%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EA%B0%81%EB%8F%84%EA%B8%B0/","title":"[Programmers] 각도기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* [programmers / 특정 문자 제거하기] my_string\tletter\tresult \u0026#34;abcdef\u0026#34;\t\u0026#34;f\u0026#34;\t\u0026#34;abcde\u0026#34; \u0026#34;BCBdbe\u0026#34;\t\u0026#34;B\u0026#34;\t\u0026#34;Cdbe\u0026#34; */ function solution(my_string, letter) { let regex = new RegExp(letter, \u0026#34;g\u0026#34;); const answer = my_string.replace(regex, \u0026#34;\u0026#34;); return answer; } replace를 바로 사용하면 되겠지? 하고 사용했는데 my_string이 \u0026ldquo;BCBdbe\u0026quot;가 되었을 때가 문제였다.\nB가 총 두번나오는데 replace를 바로 하게된다면, 맨 처음 B만 제거되고 그 이후의 B는 제거되지 않는다. 즉, CBdbe라는 값으로 결과가 나왔다.\n근데 또, 정규표현식으로 사용해볼려해도 my_string.replace(/letter/g, \u0026quot;\u0026quot;); 가 바로 적용되지 않았다\n왜냐하면 letter는 매개변수인데 매개변수로 읽히지않고, \u0026rsquo;letter\u0026rsquo;라는 문자열을 찾으라는 뜻으로 해석되었기 때문\n그래서 찾았는데 정규표현식 객체 생성사를 이용해서 패턴을 정의했다. 변하지 않는 특정 문자열을 찾을 때에는 그냥 my_string.replace(/B/g, \u0026quot;\u0026quot;);처럼 사용하면 되지만, 변할 수 있는 문자열을 찾을 때에는 아래처럼 정규표현식 객체 생성자를 이용해서 제거하면 된다.\n1 2 3 4 5 6 7 8 9 10 11 let pattern = \u0026#34;Abc\u0026#34;; let text = \u0026#34;abcabaAbcabbbcAbc\u0026#34;; let regexOne = new RegExp(pattern); // 일치하는 패턴 중 최초 등장하는 패턴 한 번만 찾음 let regexAll = new RegExp(pattern, \u0026#34;g\u0026#34;); // 모든 패턴을 찾음 let regexAllCase = new RegExp(pattern, \u0026#34;gi\u0026#34;); // 대소문자 구분 없이 모든 패턴을 찾음 console.log(text.replace(regexOne, \u0026#34;___\u0026#34;)); // abcaba___abbbcAbc console.log(text.replace(regexAll, \u0026#34;___\u0026#34;)); // abcaba___abbbc___ console.log(text.replace(regexAllCase, \u0026#34;___\u0026#34;)); // ___aba___abbbc___ console.log(text); // abcabaAbcabbbcAbc 완료 ✅\n","date":"2023-07-20T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%ED%8A%B9%EC%A0%95-%EB%AC%B8%EC%9E%90-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/","title":"[Programmers] 특정 문자 제거하기"},{"content":"2023 INFCON 2023! 분명 기억은 하고있었는데.. 정말 바빳던 7월을 지내고 있었기에 신청기간을 놓쳐버리고 나서야 기억이 났다…\n인프콘에서 너무 듣고싶었던 세션들이 너무 많았었고, 정말 다 듣고싶어서 몸이 여러개이고 싶을 정도로 정말 좋은 세션들이 많았지만 어쨋든 신청을 못한 내 잘못 😭\n그래도 인프콘에서 내 인프콘 시간표 공유하기 이벤트를 통해 다시한번의 기회가 있어 바로 신청을 하고있다\n내 인프콘 시간표 정말 많은 세션들이 있었고, 같은 시간대에 듣고싶은게 너무 많았지만 최대한 1개씩만 선택해보려고 했다..\n현재 프로젝트에 바로 도움이 될 것 같은 세션들을 위주로 선택을 했고, 더 나아가서 나의 커리어에 굉장히 영향을 많이 끼칠 것 같았다.\n혹시라도 본인도 신청을 하지 못했거나 다시한번의 기회를 얻고싶은 분이 있다면 바로 이벤트에 참여하길 바란다!\n2023 INFCON 이벤트 참여하기\n내가 들을 세션에 대해 정리해보았다.\n1-1. 타입스크립트는 왜 그럴까?: 집합으로 이해하는 타입스크립트 ⇒ 현재 Typescript, React를 기반으로 프로젝트를 진행하는데 처음 다뤄보는 Typescript라 항상 많은 문제에 꽤나 머리를 아파했다.. interface부터해서 분명 맞는 타입으로 한 것 같은데 계속 오류가 발생하고.. 이걸 들으면 조금 더 Typescript를 다루는데 용이할 것 같아 추가했다.\n1-2. 당신의 웹페이지는 몇 점 인가요?: 라이트 하우스를 통한 프런트 성능개선 ⇒ 전에 스마일게이트에서 진행한 윈터데브캠프에서 우리팀은 LCP 최적화를 하기위해 꽤 많은 노력을 기울였던 기억이 있다. 그때 사용했던 Lighthouse를 좀 더 잘 다뤘다면 LCP말고도 다른 요소들을 더 개선할 수 있지 않았을까 아쉬움이 남아 추가했다.\n2. Turborepo, Next.js, TypeScript를 이용한 프론트엔드 모노레포 적용기 ⇒ Turborepo에 대해서는 처음듣게되었는데, 프론트엔드에서의 역량을 좀 더 향상시킬 수 있지 않을까해서 추가했다.\n3. 커뮤니케이션 잘하는 개발자의 4가지 습관 ⇒ 이거는 개발자의 기본소양이라고 생각해서 추가하게 되었다. 커뮤니케이션은 언제든 항상 중요하게 생각했지만, 듣고싶었던 가장 큰 이유는 ‘토스’가 가진 커뮤니케이션의 가치를 좀 더 알고싶었다.\n4. Hello, Interactive Developer: WebGL로 아트코딩 하기 ⇒ 다이나믹하고 창의적인 인터렉션 페이지를 만들어보고싶다.. 라는 생각을 가지고는 있었지만, WebGL과 Three.js에 대해 아직 사용해본 적은 없다. 프론트엔드 개발자가 배운다면 더 강점을 가질 수 있지 않을까 해서 추가했다.\n5. 인프런에서는 수천 개의 테스트 코드를 이렇게 다루고 있어요 ⇒ 테스트코드는 더 나은 개발역량을 보여준다고 생각한다. 그렇기에 더 좋은 서비스와 코드 관리를 위해서라면 꼭 필요한데, 운이 좋게도 인프런에서의 테스트 코드 관리는 어떻게할지 궁금해서 추가하게 되었다.\n6. 주니어 프론트엔드 엔지니어의 성과 및 역량 향상을 위한 실전 가이드 ⇒ 지금 내가 제일 많이하고 있는 고민이다. 프론트엔드가 진입장벽도 낮고 배우면 누구나 할 수 있는 영역이기 때문에 경쟁력을 키울 수 있는 방법과 요즘 강력해진 ChatGPT로 인해 대체될 수 있는지에 대한 불안감이 계속 생기고있었는데, 관련해서 조언을 듣고싶어 신청하게 되었다.\nXL8의 프론트엔드 팀 리드역할을 맡고있는 배휘동님은 프론트엔드 엔지니어 커리어 로드맵: 주니어를 위한 3가지 전문성 트랙이라는 글로 주니어 프론트엔드분들께 많은 도움을 주고있습니다. 저와 같은 주니어 프론트엔드분들께 많은 도움이 될 것 같으니 시간이 된다면 한번 읽어보고 생각해보시는 것을 추천드립니다!\n7. 웹뷰를 이용해 웹 서비스를 앱으로 빠르게 구현하기 ⇒ 이것 또한 현재 하고있는 프로젝트에서도 웹과 앱을 함께 만들어야하는데 현재는 웹만이 개발되어있는 상태기때문에 앱으로 개발했을 때 도움이 되지 않을까 해서 추가했다!\n이 세션말고도 정말 능력있고 다양한 분들이 세션을 준비해주셔서 정말 기대가 된다.. 능력있는 분들이 이렇게 많은 세션들을 진행해주시는 것에 1차 놀랐고, 내가 정말로 관심을 가지고 있던 분야에 딱 걸맞는 내용을 준비해주셔서 2차로 놀랐다.\n이벤트에 당첨되서 인프콘에 참여하게 된다면 정말 좋을 것 같다 😊😊\n내 시간표 URL https://www.inflearn.com/infcon-2023/schedule/share?id=592031\u0026hash=woomg427%40772d7b68\u0026name=woomg427\n","date":"2023-07-19T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-2023-infcon-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B0%B8%EC%97%AC/7-19-thumb_hudfaab8ee98e5f94773b8a3aab54bc50a_6083552_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/join-it-2023-infcon-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%B0%B8%EC%97%AC/","title":"[Join IT] 2023 INFCON 이벤트 참여 🛠"},{"content":"U300 성장트랙 지원! 우리는 학교 동기들과 함께 창업프로젝트를 진행하고있는 와중에 국가에서 학생을 대상으로 제일 크게한다는 U300 창업공모전에서류 접수를 했었다!\n그 결과!\n우리팀(DM)은 서류합격을 할 수 있었고 경북대학교에서 우리 아이템에 대한 발표심사가 잡혔었다\n근데, 기획한 친구들이 모두 공대생들이기 때문에 언변이 화려하지 못한 것이 제일 큰 문제..(?) 앞으로 나가서 발표할 수 있는 사람이 없었는데.. 디자인팀 중 한분이 발표에는 자신이 있다고 하셔서 초조한 마음을 쓸어내릴 수 있었다.. 천만다행\n동대구로 출바알 오늘(7/18) 이렇게 원주에서 동대구 터미널까지 교통비 지원을 받아 편하게 갈 수 있었다.(무려 2시간 30분이나 걸림.. 왕복은 5시간 실화냐) 근데 가는 와중에 비가 오네..? 아나\n아무튼 우리는 동대구 터미널에 잘 도착을 했고, DICC 사업단분들이 점심식사를 같이 하자고 하셨어갖고 추천해주신 여원찜갈비를 맛있게 먹을 수 있었다!!\n돼지갈비찜이랑 소갈비찜을 모두 시켜주셨다!🤭\n맛있게 냠냠하고보니 곧 발표시간이 다가왔다.. 그래서 우리는 경북대학교 글로벌 플라자로 향했다.\n시내쪽에 있어서 이동은 편했다만 비가 많이와서 조금 힘들었다,, 경북대 글로벌플라자에 도착!\n경북대학교,,, 많이 크구나.. 키야\n1층에서 기념사진도 함께 찍고, 심사는 12층에서 이루어졌었다. 내가 생각했던 발표는 여러 사람들과 심사위원들이 모두 지켜보는 가운데에 발표를 하는 것으로 생각을 했는데, 발표팀은 대기실에 따로 있고 심사위원분들만 보실 수 있는 심사방이 따로 있었다.\n우리는 팀원 모두인 5명이 왔지만, 들어갈 수 있는 사람은 발표 진행자 1명과 Q\u0026amp;A 답변할 수 있는 1명 총 2명밖에 입장을 못했다. 다같이 볼 수 있는 줄 알고 기대했는데\u0026hellip;\n그래서 우리는 급하게 그 자리에서 Q\u0026amp;A 답변해줄 사람 1명을 정하려고했는데, 그나마 기획에 많이 참여했던 내가 가는게 나을 것 같다고 판단해서 나랑 발표해주시는 1분이랑 같이 들어가게 되었다.\n발표 심사는 총 8분으로 발표 3분 + Q\u0026amp;A 5분으로 진행되었다.\n우리 대표님께서 발표를 모두 마치고, Q\u0026amp;A에 대한 질문들이 들어왔다..\nAI가 전문적이지 않을텐데 어떻게 도와줄건지? 수익모델이 어떻게 되는지? 마케팅은 어떻게 할건지? 일시적으로 결과를 볼 수 있는 MBTI인데, 어떻게 사용자에게 장기적 앱에 머무르게 할건지? 등등.. 예상은 했지만, 우리 또한 고민을 많이 했던 것이고 쉽게 답변을 정해둘 수가 없었던 문제점들이였다. 즉, 우리의 아이템은 있지만 모호하고 정해지지 않은게 많았다. 단순히 개발만 한다고해서 끝이 아닌 것 같다. 어떤 아이템을 만들기 전에 이 아이템이 확실한 대상과 수익구조가 정해져있는지부터 봐야할 것 같다.\n우리 팀에게는 아직 그런 부분들이 미흡한 것 같다. 한번 다같이 기획을 손봐야할 것 같고 확실한 사업계획서가 하나 만들어져야할 것 같다.\n그 이후.. 우리는 발표를 끝내고 팀원들과 대구를 좀 더 구경하기 위해 핫플레이스인 동성로에 향했다!! 그래도 대구에는 왔으니까 볼 수 있는건 보고갔었으면 좋겠다고 생각했다 ㅎ_ㅎ\n먼저, 우리는 팀원들과 함께 보드게임 카페로 가서 보드게임을 즐겼다\n그리구 유명한 카페에 들러 맛있는 빵들을 포장했다!! 집에가서 부모님과 함께 먹고싶었기 때문 🤭🤭\n카페가 엄청 예뻣다 여기가 대구 동성로에 오디너리하우스라는 곳이였는데 반월당역 근처에 있다!\n이야\u0026hellip;.. 역시 대구아이가\n빵 종류도 엄청 다양했다 이곳은 천국이였군\u0026hellip; 대구에 간다면 한번씩 들러보길 바란다.\n우리는 다시 원주로 돌아가기 위해 동대구로 향했다!\n그리고 동대구 터미널에 있는 햄버거 집에서 마지막 만찬을 만끽했다..! 버거스올마이티라는 곳인데.. 햄버거도 엄청 부드럽고 패티도 수제패티라 정말 맛있었다. 더군다나 감튀는 ㄹㅇ 짭쪼름한게 내 입맛에 딱임\n그리고는 버스에 올라타 원주에 도착을 하고 지금은 본가에서 이 글을 쓰고있다\n결론 이동하는데에 거의 반을 보내서 힘들게 없었지만 이동하는거 자체가 힘들었다\u0026hellip; 동기들과 함께 창업을 한다고 이렇게 U300도 도전해보고 여러가지 활동도 경험해볼 수 있어서 좋다. 하지만, 창업이 정말 쉽지만은 않은 것 같다. 아이디어도 매우 중요하지만 어떤 대상을 할건지도 그렇고 어떻게 수익을 낼건지도 그렇고 어떻게 홍보를 할건지, 인건비는 어떻게 할건지\u0026hellip; 등등 생각해야 할 것들이 너무 많다.\n그럼에도 다들 창업을 준비하는 이유가 뭘까? 단지 직원으로 일하게되면 돈을 많이주지 않아서일까? 아니면 내가 정말로 하고싶은 아이템이 생겨서일까?\n사람마다 다르겠지만, 나는 아직 창업을 하고싶다는 생각은 크게 없다.. 그냥 창업을 하는 과정에서 어려움들을 잘 헤쳐나갈 수 있는 경험들을 느껴보고싶고, 팀원들과의 협력도 같이 해보고싶었기 때문이다.\n호기심으로 시작해서 실제로 큰 사업으로 진출되는 경우도 있지만 그 호기심을 생각하고 실천하는 과정을 알기 위해서는 경험이 많이 필요하다고 생각된다. 아직까지는 많이 부족하고 아는 것도 없지만 여러활동을 하다보면 분명 언젠가는 도움이 될거라고 생각한다.\n이렇게 블로그를 쓰는 것도 지금은 의미가 없을지 몰라도 언젠가는 도움이 되지 않을까?? 😄\n아무튼 오늘도 고생 많이했다 나 자신!\n","date":"2023-07-18T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-u300-%EC%B0%BD%EC%97%85%EA%B3%B5%EB%AA%A8%EC%A0%84-%EB%B0%9C%ED%91%9C/7-18-thumb_huff99803c930289881865235670515475_54857_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/join-it-u300-%EC%B0%BD%EC%97%85%EA%B3%B5%EB%AA%A8%EC%A0%84-%EB%B0%9C%ED%91%9C/","title":"[Join IT] U300 창업공모전 발표"},{"content":"Microsoft AI \u0026amp; Cloud 러닝캠프 by MLSA 후기 오늘은 마이크로소프트에서 MLSA분들과 함께하는 세미나에 참가했다!\n졸업하신 선배님께서 이런 행사도 있는데 한번 가보는거 어떻게 생각하냐고 추천해주셔서 마침 딱 관심있는 분야기도해서 주저없이 바로 신청을 해버렸다. (이런 행사를 계속 가보면 좋겠지만… 지방의 머학생에겐 교통비가… 으악)\n제일 기대됐던건 마이크로소프트에 방문해보는게 제일 기대됐다. 어렸을 때부터 광화문 바로 앞에 보이는 마이크로소프트 건물을 자주 보긴했지만 이렇게 직접 안으로 들어가보는건 처음이라 설렜다…\n키야\u0026hellip; 영롱한 마이크로소프트\n서론이 길었는데, 본론으로 넘어가서 MS사무실 앞에 갔는데 다른 대학생분들도 굉장히 많았다. 역시 마소에서 진행하는거다보니 관심들이 많았다고 생각한다.\n우리의 세미나 행사일정은 다음과 같이 진행하였다 사실, MLSA라는 활동은 행사에와서 처음 들어봤다. 이런 활동이 있었는지도 몰랐고, 나는 기존에 Google에서 진행하는 GDSC에 Core member로는 있어봤지만, MS에도 대학생들을 위한 커뮤니티가 있었다니..\nMLSA는 정확히 말하면 Microsoft Learn Student Ambassadors. 즉, 학생들을 위해 MS에서 지원해주는 학생 커뮤니티이다. 필요한 기술과 커뮤니티를 강화시켜주고 리더쉽의 역량을 좀 더 향상시켜줄 수 있는 활동이다.\nMLSA가 되면 혜택을 받을 수 있는데, 등급에 따라 혜택이 달라진다.\nMLSA에는 총 3가지 등급이 존재하는데\n알파 베타 골드 현재 한국에는 Gold 등급을 받으신 분이 없다고하니… 만약 본인이 Gold를 한번 해보고싶다하면 도전해보시길 추천드립니다! 또한, 본인이 MLSA에 관심이 있다하면 당장 신청하길..!! 정말 좋은 활동이라 생각되고, 여러 사람들과 커뮤니티를 할 수 있다는 점이 굉장히 좋을 것 같다.\n참고로, 지원서를 낼 때는 모든 Form을 영어로 작성해야하고 영어 면접 영상도 1분정도 가량 찍어야한다고 하니 참고바란다.\nMLSA 신청하기 👉🏻👉🏻 https://studentambassadors.microsoft.com/\n처음 세션으로는 MLSA 리더분들이 MLSA에 대한 소개와 어떻게 참가할 수 있는지 등에 대해 설명해주셨다.\n그리고, 그 이후로는 MLSA분들 주도하에 세미나가 진행이 되었다.\n나는 현재 하고있는 프로젝트가 있기때문에 좀 더 도움이 되고자 Section 2를 선택해서 세미나를 수강했다.\n시간이 많이 촉박해서 완전한 실습으로는 진행하지 않았다. 다만 자료를 보고 집에가서도 충분히 해볼 수 있도록 PPT를 만들고 배포까지 해주실 예정이라고 하셨다.\n확실하게 기억하는건 Azure가 되게 괜찮은 Cloud computing 플랫폼이라는 것은 알게되었다. 현재는 프론트엔드지만, Next.js처럼 서버리스같은 서비스를 기획하고 만들어보고싶었다.\n또한, 어떤 공모전을 할 때 빠르게 서비스를 기획하고 구축하려면 필요한 플랫폼이긴 하다. 그래서 조금씩 Azure를 사용하면서 백엔드도 같이 공부해보고 토이프로젝트로도 만들어보고 하면 좋을 것 같다.\n그래서 2개의 세미나(Azure App Service로 소셜 로그인 기능 간단하게 구현하기, Perfect PaaS Azure 배포의 모든 것)를 들은게 큰 도움이 되었다.\nPaaS라는 것도 많이 들어보긴 했지만, 어떤 개념인지는 정확히 알지 못했는데, 한 MLSA 리더님이 IaaS와 SaaS와 PaaS의 개념이랑 차이점까지 비유를 들어 이해하기 쉽게 얘기해주셔서 너무 좋았다. 역시 리더를 하려면 이렇게 어려운 개념도 재밌고 이해하기 쉽게 말해주는 능력도 필요하구나 라고 생각함.. MLSA분들 짱 👍🏻🤭\n그 이후 오후 4시부터는 MS직원 8분이 가볍게 본인소개와 조언을 해주시고 질의응답을 받았다.\n사실 궁금한게 너무나도 많았고, 물어보고싶은게 오조오억개인데 나의 쑥쓰러움을 이기지 못하고 질문을 한개도 못했었다.. 물론 질문하려는 분들도 매우 많았기 때문인데 그렇게 사람들 눈치보지 않고 당당하게 질문할 수 있는 능력을 좀 키우고싶다..ㅜㅜ 어딜가도 질문한다는 것은 되게 좋은 습관인데 처음이 힘들다… 처음만 잘 해내면 그 이후로는 쉽게 할 수 있을텐데 항상 그 처음이라는 벽을 넘지 못하는 것 같아 스스로 화가 나기도 한다.\n그건 그렇지만, 다른 분들의 질문들도 되게 도움되는 질문들도 많았고 직원분들의 조언을 들으면서 다시 곰곰하게 생각해본 것도 있다. 특히나 기억에 남았던건, 현재는 대표님이신 분께서 산티아고 순례길을 갔다고 했는데 아직 학생으로 보이는 유럽 청년들이 학교를 가지않고 순례길을 걷고있길래 “대학교에 가야할텐데 왜 가지 않고 순례길을 가고있나요?”라고 물어보셨다고 그런데, 유럽 청년이 “뭘 해야할지 모르겠는데 왜 대학교를 가야하는거죠?”라고 답변하셨다고 한다.\n그 답변을 듣고 우리가 지금 진행하고 있는 프로젝트와 너무 연관이 되어있는 것 같아 순간의 문장이 뇌리 속에 박혔다.\n사람이 본인이 뭘 좋아하는걸 안다는 것은 매우 좋은 깨달음인 것 같다. 나 또한 컴공이라는 분야에서도 어떤 것을 하고싶은지 모른채로 서성이고 있을 때가 많다. 어떻게 보면 컴공도 내가 정말 좋아서 간걸까? 라는 생각이 들기도 했고, 단지 요즘 트렌드가 컴공쪽에 치우쳐져서 그 유행을 따라가는게 아닐까 라는 생각도 해봤다.\n물론, 내가 어떤 분야에 관심이 생기기 전까지 말이다.\n그런데 요즘은 나는 확실히 Front-end라는 분야가 나에게 맞는 것 같다 라고 느꼈다. 재밌기도 하고, Front-end에서 트렌드가 바뀔 때 마다 찾아보는 것도 흥미롭고 변화를 좋아하는 나에게는 아주 잘 맞는 분야인 것 같다.\n어쨋든, MLSA분들이 이렇게 세미나를 개최해주시는 바람에 AI와 Cloud에 관심이 가기 시작한 나에게는 아주 도움되는 자리였고 현직자분들이 직접 조언을 해주시니 더 믿음직스럽고 든든했다.\n앞으로도 이런 활동이 있다면 더욱더 적극적으로 참여해 볼 생각이다! 오늘도 고생했다. 나 자신!\n","date":"2023-07-15T00:00:00Z","image":"https://myeongcode.github.io/p/join-it-microsoft%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-%EB%8C%80%ED%95%99%EC%83%9D-ai-cloud-%EB%9F%AC%EB%8B%9D-%EC%BA%A0%ED%94%84-by-mlsa/7-15-thumb_hu44df74f2134f29323f55508cc91599cf_1050959_120x120_fill_q75_box_smart1.jpeg","permalink":"https://myeongcode.github.io/p/join-it-microsoft%EC%99%80-%ED%95%A8%EA%BB%98%ED%95%98%EB%8A%94-%EB%8C%80%ED%95%99%EC%83%9D-ai-cloud-%EB%9F%AC%EB%8B%9D-%EC%BA%A0%ED%94%84-by-mlsa/","title":"[Join IT] Microsoft와 함께하는 대학생 AI \u0026 Cloud 러닝 캠프 by MLSA"},{"content":"서론 🌐 React에 대해서 정확히 설명할 수 없었던 나이기에 React를 사용했던 경험을 떠올려 다시한번 복습을 하고 정확한 React를 알기 위해 정리를 해보겠습니다.\nReact란? React는 웹 프레임워크로 자바스크립트 라이브러리의 하나로서 특히 SPA(Single Page Application)을 위한 사용자 인터페이스를 구축하는데 사용됩니다.\n즉, 현재 많이 활용되고 있는, 웹/앱의 View를 개발할 수 있는 인기 라이브러리죠\nSPA(Single Page Application) 단일 페이지 어플리케이션\n즉, 어떠한 웹 사이트의 전체 페이지를 하나의 페이지에 담아 동적으로 화면을 변경해 표시하는 기술\n더 자세한 내용은 아래 링크에서 확인\nJONGMINFIRE.DEV님의 \u0026ldquo;SPA(Single Page Application)란?\u0026rdquo;\nReact의 필요성 사실은 React를 사용하지 않아도, html과 css, javasciprt를 이용해서 웹 페이지를 만들 수 있지만, react를 이용하면 사용자와 상호작용할 수 있는 동적인 UI를 쉽게 만들 수 있습니다.\nSPA을 만들 때 좋습니다. 모바일 앱처럼 전체화면 새로고침 없이 부드럽게 만들고 싶을 때 사용합니다.\n재사용이 편리합니다. html을 함수, array, object 이런 곳에 보관하고 재사용할 수 있어서 큰 프로젝트 일 수록 html 관리가 편리해집니다. 또, ReactNative를 쓰면 같은 리액트 문법으로 모바일 앱개발도 가능합니다.\nReact 특징 JSX React에서는 템플릿에 일반 JavaScript를 사용하는 대신 JSX를 사용합니다. JSX는 HTML 인용을 허용하고 이러한 HTML 태그 구문을 사용하여 하위 구성 요소를 렌더링하는 간단한 JavaScript입니다.\nData Flow(Flux) React는 데이터의 흐름이 한 방향으로만 흐르는 단방향 데이터 흐름(Flux)을 가집니다.\nAngular.js와 같은 양방향 데이터 바인딩은 규모가 커질수록 데이터의 흐름을 추적하기가 힘들고 복잡해지는 경향이 있어, 복잡한 앱에서도 데이터 흐름에서 일어나는 변화를 보다 예측가능할 수 있도록 단방향 흐름을 가지도록 했다고 합니다.\nComponent 기반 구조 Component는 독립적인 단위의 소프트웨어 모듈을 말합니다. 즉, 소프트웨어를 독립적인 하나의 부품으로 만드는 방법이라고 볼 수 있습니다.\nReact는 UI(View)를 여러 컴포넌트로 쪼개서 만듭니다. 한 페이지 내에서도 여러 각 부분을 독립된 컴포넌트로 만들고, 이 컴포넌트를 조립해 화면을 구성합니다.\n컴포넌트 단위로 쪼개져있기 때문에, 전체 코드를 파악하기 상대적으로 쉽습니다. 이렇게 기능 단위, UI 단위로 캡슐화시켜 코드를 관리하기 때문에 재사용성이 높습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class App extends Component { render() { return ( \u0026lt;Layout\u0026gt; \u0026lt;Header /\u0026gt; \u0026lt;Navigation /\u0026gt; \u0026lt;Content\u0026gt; \u0026lt;Sidebar\u0026gt;\u0026lt;/Sidebar\u0026gt; \u0026lt;Router /\u0026gt; \u0026lt;/Content\u0026gt; \u0026lt;Footer\u0026gt;\u0026lt;/Footer\u0026gt; \u0026lt;/Layout\u0026gt; ); } } Virtual DOM (Document Object Model) 원래, DOM은 html, xml, css 등을 트리 구조로 인식하고, 데이터를 객체로 간주하고 관리합니다.\n하지만, 페이지를 수정할 때 마다 DOM 트리를 계속 새로 그려줘야하고 수정할 데이터를 DOM에서 모두 찾아서 수정해야하기 때문에 성능과 비용적인 측면에서 손실이 큽니다.\n그래서 React에서는 DOM Tree 구조와 같은 구조체 Virtual DOM이라는 가상의 문서 객체 모델을 만들어 이벤트가 발생할 때 마다 Vitrual DOM을 만들고 다시 그릴 때마다 실제 DOM과 비교하고 전/후 상태를 비교해, 변경이 필요한 최소한의 변경사항만 실제 DOM에 반영해, 앱의 효율성과 속도를 개선할 수 있습니다.\nProps \u0026amp; State Props\nprops는 부모 컴포넌트에서 자식 컴포넌트로 전달해주는 데이터를 말합니다 쉽게 읽기 전용 데이터라고 생각하면 될 것 같습니다. 자식 컴포넌트에서 전달받은 Props는 변경이 불가능하고 props를 전달해준 최상위 부모 컴포넌트만 props를 변경할 수 있습니다.\nState\nState는 컴포넌트 내부에서 선언하며 내부에서 값을 변경할 수 있습니다. state는 동적인 데이터를 다룰 때 사용하며, 사용자와의 상호작용을 통해 데이터를 동적으로 변경할 때 사용합니다. 다만, state를 바꿀 때에는 [state, setState] = useState(value)형식에서 setState()라는 함수로 변경해야합니다.\nReact 장단점 React의 장점 빠른 업데이트와 렌더링 속도\n위에서 말했듯, React는 빠른 업데이트를 위해 Virtual DOM이라는 것을 사용하여 어떤 DOM 상태의 변경이 일어나야한다면 Vitrual DOM에서는 변경해야 할 최소한의 부분을 검색(Compute Diff)하여 검색한 부분만을 업데이트하고 렌더링하기 때문에 렌더링 속도가 상대적으로 빨라진다.\n재사용성\n리액트는 모든 페이지가 컴포넌트로 구성되어져있고 하나의 컴포넌트는 다른 여러 개의 컴포넌트로 구성되어 질 수 있습니다. 마치 레고 블록을 조립하듯 컴포넌트들을 조립해서 개발할 수 있다는 것입니다.\n활발할 지식공유 및 커뮤니티\n구글링만 해도 잘 나온다.\nReact Native\n리액트 문법을 사용해서 모바일 환경도 개발할 수 있다는 장점이 있다.\nReact의 단점 IE8 이하 버전은 지원하지 않는다.\nView 이외의 기능은 직접구현하거나 라이브러리를 사용해서 구현해야하기에 javascript 배경지식이 필수 선생이다.\n데이터 모델링, 라우팅, Ajax 등 기능 지원이 안된다.\n앱의 규모가 커지면 속도가 느려진다.\n높은 상태관리 복잡도\n","date":"2023-06-04T00:00:00Z","image":"https://myeongcode.github.io/p/react-react%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC/react-logo_hua3ebe5898a4e39adc84559693d29cf1f_231564_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/react-react%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A0%95%EB%A6%AC/","title":"[React] React에 대한 정리"},{"content":"JIRA란? 프로젝트에서 애자일 방법론을 적용할 때의 프로젝트 관리 협업 툴\n가장 기본이 되는 단위 : 이슈(Issue) ⇒ 이슈란 팀이 식별하고 있는 작업 항목의 단위로서, 하나의 업무 당 하나의 이슈가 배정됩니다.\n이슈를 등록하고 관리하는 과정에서 우리는 업무계획을 수립할 수 있고, 업무 사이클에 맞게 내게 주어진 일을 진행하고 완료할 수 있습니다.\n지라의 이슈에는 다양한 타입이 있습니다.\n에픽(Epic) : 정해진 업무에 따라 다른 이슈를 포함한 조금 더 큰 범주의 이슈 스토리(Story) : 사용자의 요구사항을 담은 스토리 태스크(Task) 버그(Bug) 등등 이슈를 만드는 방법은 지라 상단 메뉴바에서 만들기(Create) 버튼을 클릭하면 이슈를 생성할 수 있습니다.\n이 때, 각 이슈별로 이슈 key(프로젝트키-이슈숫자형식)가 자동으로 생성되는데 이 키를 구성원들과 공유하여 어떤 이슈에 대해 이야기를 하는지 싱크를 맞출 수 있습니다.\n각 이슈의 내용을 뜻하는 필드(Field)를 잘 구성하고 작성해야 업무에 있어 꼭 필요한 정보를 기록으로 남기고, 구성원 간에 오해없이 같은 내용을 공유할 수 있습니다.\n이슈에는 다양할 필드가 존재하는데, 지라를 활용할 때 가장 필수적인 필드 항목 세 가지만 꼽자면\n요약 : 이슈의 제목 해당 업무를 가장 잘 정리한 문장 혹은 문구를 작성해야, 전체 업무를 파악할 때 어려움이 없습니다. 담당자 : 해당 업무를 진행할 담당자 지라에서는 한 이슈 당 하나의 담당자만 할당할 수 있는데 이는 R\u0026amp;R(Role and Responsibilities : 업무분장)을 명확하게 하고 누가 어떤 업무를 진행하는지 알 수 있는 가시성을 확보 담당자가 여러 명일 경우에는 하위작업(Sub Task)를 활용하거나, 관련자(Stakeholder)필드를 구성하면 됩니다. 우선순위 : 업무의 긴급성과 중요성 High / Medium / Low 등으로 나누어 중요하고 긴급한 업무와 그렇지 않은 업무를 구분할 수 있습니다. 💡 업무 히스토리 추적을 위해 필드별로 업데이트 되는 이벤트 내역이 생길때마다 코멘트를 남기는 것을 추천합니다. 또, 이슈 삭제 권한을 일반 유저에게 주지 않는 것이 좋습니다. 커뮤니케이션이 잘 되고, 신뢰와 협업을 기반으로 일을 한다면 이슈를 삭제할 이유가 없습니다.\n업무 시각화 공간 : 프로젝트(Project) ⇒ 지라에서 가장 기본이 되는 단위가 이슈라면, **연관된 이슈들의 집합이 바로 프로젝트(Project)**입니다.\n하나의 이슈는 단 하나의 프로젝트에만 소속하기 때문에, 프로젝트는 각 팀이 진행해야 하는 할 일 리스트하고도 볼 수 있습니다.\n지라 프로젝트 칸반 보드 지라 프로젝트 스크럼 보드 지라 프로젝트 로드맵 알아야 할 중요한 JIRA 핵심 용어 백로그 : 우선순위를 정해야하는 집중 작업 목록 스토리 포인트 : 노력, 복잡성 및 위험에 대한 0-8 척도에 의존 스크럼 보드 : 클라이언트 중심의 모든 프로젝트에 사용되며, 일반적으로 할 일, 진행 중, 완료된 컬럼과 같은 주요 요소로 구성됩니다. 칸반 보드 : 주로 제품과 관련된 업무에 사용 레이블 : 레이블은 모든 문제를 분류하는 데 필요합니다. 또한 문제를 빠르게 찾는데 도움이 됩니다. 워크플로 : 워크플로는 보드 열 사이에서 스토리를 이동합니다. 스토리 : 사용자 스토리에는 요청에 필요한 모든 것이 포함됩니다. 작업 로그 : 수행된 모든 작업의 목록을 포함합니다. 디시젼 로그 : 내린 모든 결정의 목록을 포함합니다. 에픽 : 작업의 큰 덩어리를 더 작고 더 쉬운 단계로 나눕니다. 위험 로그 : 프로젝트 작업 수행 중 식별된 위험 목록 기술적 작업 : 프로젝트의 작은 작업 JIRA의 장점 워크플로 가시성 향상 프로세스를 자동화하고 실시간으로 진행 상황을 추적하여 워크플로에 대한 더 나은 가시성을 제공 시간 추적 각 작업에 소요된 시간을 자동으로 기록하며, 프로세스를 최적화하고 효율성을 개선하며 리소스를 더 잘 활용하는 데 사용 생산성 향상 유연한 문제 추적 시스템을 통해 작업을 보다 효율적으로 추적 및 관리 JIRA의 단점 초보자가 쓰기에는 복잡함 초보자가 사용할 때의 UI가 직관적이지 않음 커뮤니케이션의 부재 프로젝트 관리를 위한 훌룡한 도구이지만 커뮤니케이션 기능이 부족함 Reference 일 잘하는 팀의 실전 ‘지라(Jira)’ 활용법 - 업무용 협업툴 JANDI 블로그\n","date":"2023-06-03T00:00:00Z","image":"https://myeongcode.github.io/p/jira-jira%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/jira-logo_hu5a45f1008d9b0d027dd43621df4b7488_246608_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/jira-jira%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/","title":"[JIRA] JIRA가 무엇일까?"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [programmers / 문자열 반복 출력하기] my_string\tn\tresult \u0026#34;hello\u0026#34;\t3\t\u0026#34;hhheeellllllooo\u0026#34; */ function solution(my_string, n) { var splitString = my_string.split(\u0026#34;\u0026#34;); let answer = \u0026#34;\u0026#34;; for (let i = 0; i \u0026lt; my_string.length; i++) { for (let j = 0; j \u0026lt; n; j++) { answer += splitString[i]; } } return answer; } 그냥 문자열 개수만큼 반복하였고, 또 매개변수로 받은 n만큼 반복하여 각 문자마다 3번씩 반복하게 만들었다.\n완료 ✅\n","date":"2023-05-12T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%AC%B8%EC%9E%90-%EB%B0%98%EB%B3%B5-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%AC%B8%EC%9E%90-%EB%B0%98%EB%B3%B5-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/","title":"[Programmers] 문자 반복 출력하기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* [programmers / 직각삼각형 출력하기] 입력 #1 3 출력 #1 * ** *** */ const readline = require(\u0026#34;readline\u0026#34;); const rl = readline.createInterface({ input: process.stdin, output: process.stdout, }); let input = []; rl.on(\u0026#34;line\u0026#34;, function (line) { input = line.split(\u0026#34; \u0026#34;); }).on(\u0026#34;close\u0026#34;, function () { for (let i = 0; i \u0026lt; Number(input); i++) { console.log(\u0026#34;*\u0026#34;.repeat(i + 1)); } }); readline을 처음보고 벙쪘다.. 이게 무슨 코드인지 몰라서..\nreadline이란? Readable Stream에서 한 번에 한 줄씩 데이터를 읽기 위한 인터페이스를 제공하는 모듈\n즉, 입출력을 처리하게해주는 JS 내장 모듈입니다.\nreadline 사용법 모듈 불러오기 1 const readline = require(\u0026#34;readline\u0026#34;); interface 객체 만들기 interface 객체를 이용하여 콘솔에서 표준 입출력 처리를 할 수 있습니다.\n1 2 3 4 const rl = readline.createInterface({ input: process.stdin, output: process.stdout, }); stdin : standard input stdout : standard output 입출력 코드 작성하기 1 2 3 4 5 6 7 8 9 rl.on(\u0026#34;line\u0026#34;, (line) =\u0026gt; { // 입력 받은 값을 처리하는 코드 rl.close(); }); rl.on(\u0026#34;close\u0026#34;, () =\u0026gt; { // 입력이 끝나고 실행하는 코드 process.exit(); }); on() : 메서드를 활영하여 이벤트와 콜백함수를 전달 'line' : 입력받은 값을 한 줄씩 읽어 문자열 타입으로 전달하는 역학을 하는 이벤트. rl.close() : 인터페이스를 종료. 무한히 입력 받는 것을 방지하며, close를 작성하여 입력이 끝난 후 실행되어야 할 함수를 작성합니다. 아무튼 readline은 아래에 조금 더 내용을 참조하였고, 우리는 3을 입력받았으므로 직각삼각형 모양으로 별을 출력해줘야한다.\n그러기위해서는 반복되어야하는 for문을 사용했고, 출력될 때 repeat()를 사용하여 for문을 반복한 만큼 *을 찍게했다.\n근데 여기서 별이 처음부터 찍혀야하니 repeat(i+1)을 해주었다.\n완료 ✅\n","date":"2023-05-12T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%A7%81%EA%B0%81%EC%82%BC%EA%B0%81%ED%98%95-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%A7%81%EA%B0%81%EC%82%BC%EA%B0%81%ED%98%95-%EC%B6%9C%EB%A0%A5%ED%95%98%EA%B8%B0/","title":"[Programmers] 직각삼각형 출력하기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* [programmers / 문자열 뒤집기] my_string\treturn \u0026#34;jaron\u0026#34;\t\u0026#34;noraj\u0026#34; \u0026#34;bread\u0026#34;\t\u0026#34;daerb\u0026#34; */ function reverseString(string) { let splitString = string.split(\u0026#34;\u0026#34;); let reverseString = splitString.reverse(); let joinArray = reverseString.join(\u0026#34;\u0026#34;); return joinArray; } function solution(my_string) { var answer = reverseString(my_string); return answer; } reverseString이라는 문자열을 뒤집어주는 함수를 하나 만들고\n문자열 분해 .split(\u0026quot;\u0026quot;) ➡️ 문자열 뒤집기 .reverse() ➡️ 문자열 합체 .join(\u0026quot;\u0026quot;) 순으로 진행을 해주었다.\n완료 ✅\n","date":"2023-05-02T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%AC%B8%EC%9E%90%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/","title":"[Programmers] 문자열 뒤집기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* [programmers / 짝수 홀수 개수] num_list\tresult [1, 2, 3, 4, 5]\t[2, 3] [1, 3, 5, 7]\t[0, 4] */ function discrimination(num_list) { let odd = 0, even = 0; for (let i = 0; i \u0026lt; num_list.length; i++) { if (num_list[i] % 2 == 0) { even++; } else { odd++; } } return [even, odd]; } function solution(num_list) { let answer = discrimination(num_list); return answer; } 짝수인지 홀수인지 판별하는 함수 discrimination을 만들고 return을 [짝수, 홀수]로 반환해줬다.\n짝수인지 아닌지는 2를 나눠서 나머지가 0이면 짝수인거니까 even을 1씩 증가시키고, 2를 나눠서 0이 아니면 홀수이므로 odd를 1씩 증가시켜줬다.\n완료 ✅\n","date":"2023-05-02T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%A7%9D%EC%88%98-%ED%99%80%EC%88%98-%EA%B0%9C%EC%88%98/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%A7%9D%EC%88%98-%ED%99%80%EC%88%98-%EA%B0%9C%EC%88%98/","title":"[Programmers] 짝수 홀수 개수"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* [programmers / 아이스 아메리카노] age\tresult 40\t1983 23\t2000 */ function solution(age) { let default_year = 2022; let born; born = default_year - age + 1; return born; } 2022년에 살고있었다면 getFullYear()를 사용했을텐데, 현재는 2023년이라서 그냥 2022년을 디폴트년도로 잡았다.\n완료 ✅\n","date":"2023-04-30T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%82%98%EC%9D%B4-%EC%B6%9C%EB%A0%A5/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%82%98%EC%9D%B4-%EC%B6%9C%EB%A0%A5/","title":"[Programmers] 나이 출력"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 /* [programmers / 배열 뒤집기] num_list\tresult [1, 2, 3, 4, 5]\t[5, 4, 3, 2, 1] [1, 1, 1, 1, 1, 2]\t[2, 1, 1, 1, 1, 1] [1, 0, 1, 1, 1, 3, 5]\t[5, 3, 1, 1, 1, 0, 1] */ function solution(num_list) { var answer = num_list.reverse(); return answer; } js에서 제공하는 메서드인 .reverse()만 사용하면 쉽다.\n완료 ✅\n","date":"2023-04-30T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%B0%B0%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%B0%B0%EC%97%B4-%EB%92%A4%EC%A7%91%EA%B8%B0/","title":"[Programmers] 배열 뒤집기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [programmers / 아이스 아메리카노] money\tresult 5,500\t[1, 0] 15,000 [2, 4000] */ function solution(money) { let americano = 5500; let americano_cnt, remain_money; americano_cnt = parseInt(money / americano); remain_money = parseInt(money % americano); return [americano_cnt, remain_money]; } 쉽게 몫과 나머지를 구하면 아메리카노의 잔 수와 잔돈을 알 수 있다. 정수로 return해줘야하므로 parseInt() 사용\n완료 ✅\n","date":"2023-04-28T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%95%84%EC%9D%B4%EC%8A%A4-%EC%95%84%EB%A9%94%EB%A6%AC%EC%B9%B4%EB%85%B8/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%95%84%EC%9D%B4%EC%8A%A4-%EC%95%84%EB%A9%94%EB%A6%AC%EC%B9%B4%EB%85%B8/","title":"[Programmers] 아이스 아메리카노"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* [programmers / 옷가게 할인받기] 입출력 예 price\tresult 150,000\t142,500 580,000\t464,000 */ function solution(price) { let result; if (price \u0026gt;= 500000) result = price - price * 0.2; else if (price \u0026gt;= 300000) result = price - price * 0.1; else if (price \u0026gt;= 100000) result = price - price * 0.05; else result = price; return result; } 먼저 걸려야하는 50만원 \u0026gt; 30만원 \u0026gt; 10만원 순으로 if 조건문을 걸어주어 계산을 진행하였음.\n음?\u0026hellip; 뭐지 뭐가 문제일까\u0026hellip;.?\n아 잘보니까 제안사항에 소수점 이하를 버린 정수를 return합니다. 라고 적혀있었음.\n그래서 테스트 중에 소수점으로 나오는 것들이 있어 실패를 한 것 같다.\n그래서 return할 때 정수로 반환해주기 위해 parseInt()를 덧붙였다.\n완료 ✅\n","date":"2023-04-28T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%98%B7%EA%B0%80%EA%B2%8C-%ED%95%A0%EC%9D%B8-%EB%B0%9B%EA%B8%B0/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%98%B7%EA%B0%80%EA%B2%8C-%ED%95%A0%EC%9D%B8-%EB%B0%9B%EA%B8%B0/","title":"[Programmers] 옷가게 할인 받기"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* [programmers / 배열의 평균값] 입출력 예 numbers\tresult [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\t5.5 [89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]\t94.0 */ function solution(numbers) { let sum = 0; let answer; for (let i = 0; i \u0026lt; numbers.length; i++) { sum += numbers[i]; } answer = (sum / numbers.length).toFixed(1); return answer; } 배열의 개수만큼 다 더한 값을 배열의 개수로 나뉘면 쉽게 평균값을 구할 수 있다.\n근데 문제에서 .0또는 .5인 경우만 정답으로 처리된다는 것 같길래 .toFixed(1)로 소수점 아래 1자리까지 표기해주었음.\n완료 ✅\n","date":"2023-04-25T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%89%EA%B7%A0%EA%B0%92/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%B0%B0%EC%97%B4%EC%9D%98-%ED%8F%89%EA%B7%A0%EA%B0%92/","title":"[Programmers] 배열의 평균값"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [programmers / 피자 나눠먹기 - 3] 입출력 예 slice\tn\tresult 7\t10\t2 4\t12\t3 */ function solution(slice, n) { let defaultSlice = slice; let person = n; const pizza = Math.ceil(person / defaultSlice); return pizza; } 피자 나눠먹기 - 1 처럼 기본적으로 피자 1개에 slice조각으로 나뉘어주는데 피자조각보다 먹어야하는 사람이 더 많을경우 소수점으로 나오므로 올림을 하여 피자의 개수를 늘리도록 함.\n완료 ✅\n","date":"2023-04-25T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-3/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-3/","title":"[Programmers] 피자 나눠먹기 - 3"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* [programmers / 피자 나눠먹기 - 1] 입출력 예 n\tresult 7\t1 1\t1 15\t3 */ function solution(n) { let defaultSlice = 7; let person = n; const result = Math.ceil(person / defaultSlice); return result; } 기본적으로 피자 1개에 7조각으로 나뉘어주는데 피자조각보다 먹어야하는 사람이 더 많을경우 소수점으로 나오므로 올림을 하여 피자의 개수를 늘리도록 함.\n완료 ✅\n","date":"2023-04-24T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-1/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-1/","title":"[Programmers] 피자 나눠먹기 - 1"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /* [programmers / 피자 나눠먹기 - 2] 입출력 예 n\tresult 6\t1 10\t5 4\t2 */ function gcd(a, b) { let result; while (b != 0) { result = a % b; a = b; b = result; } return a; } function solution(n) { let defaultSlice = 6; let person = n; let lcm; if (person \u0026lt; defaultSlice) { lcm = (person * defaultSlice) / gcd(defaultSlice, person); return lcm / 6; } else { lcm = (person * defaultSlice) / gcd(person, defaultSlice); return lcm / 6; } } 이 문제는 보자마자 최소공배수를 구하면 되겠구나 하는 생각이 먼저들었음.\n그래서 최소 공배수를 구하기 위해 먼저 최대공약수를 구하기 위해 gcd(a, b)를 만들어서 그 결과를 return했고, 최소공배수 = 두 수의 곱 / 최대공약수이므로 그 값을 피자 조각인 6으로 나누어 피자의 개수를 return하였다.\n사실 최소공배수를 어떻게 구하지 막막했는데 \u0026lsquo;최소공배수를 구하는 법\u0026rsquo;을 치니까 유클리드 호제법이라는 것이 언급되었다.\n유클리드 호제법 유클리드 호제법은 2개의 자연수의 최대공약수를 구하는 알고리즘의 하나이고, 두 수가 서로 상대방 수를 나누어서 결국 원하는 수를 얻는 알고리즘이다.\n2개의 자연수 a, b에 대해서 a를 b로 나눈 나머지를 r이라 하면(단, a \u0026gt; b), a와 b의 최대 공약수는 b와 r의 최대공약수와 같다.\n좀, 말이 어려울 수도 있는데 간단히 말하자면\na를 b로 나눈 나머지를 r이라 했고, 또 b를 r로 나눈 나눈 나머지를 r\u0026rsquo;이라 하고, 또 r을 r\u0026rsquo;로 나눈 나머지를 r\u0026rsquo;\u0026rsquo; 이런식으로 과정을 반복해서 나머지가 0이 되었을 때 마지막으로 나누는 수가 최대공약수가 되는 것이다.\n계산 예 만약 a가 24, b가 18이라고 해보자\nGCD a b a % b 1회 GCD(24, 18) 24 18 6 2회 GCD(18, 6) 18 6 0 2번째 시도만에 나머지가 0으로 떨어졌으며, 결국 마지막에 나누는 수(6)이 최대공약수가 되는 것이다.\n그래서 이것을 코드로 작성한 것이 gcd(a, b)에 해당이 되는 것이고, 최대공약수를 알면 최소공배수는 바로 구할 수 있다.\n최소공배수 = 두 수의 곱 / 최대공약수\n그리고 마지막으로 피자의 조각이 아닌 피자의 개수를 구하는 것이므로 6조각 당 1개이므로 6으로 나눈 몫을 return하여 피자의 개수를 구하였다.\n완료 ✅\n","date":"2023-04-24T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-2/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%ED%94%BC%EC%9E%90-%EB%82%98%EB%88%A0%EB%A8%B9%EA%B8%B0-2/","title":"[Programmers] 피자 나눠먹기 - 2"},{"content":"오늘은 어머니 동창회가 있는 날! 경기도 의왕에서 동창회를 한다길래 나랑 아버지는 따라가서 어머니 동창회 끝난 후에 같이 놀러다니기로 했다!\n그래서 아침 8시에 일어나서 주섬주섬 준비하기 시작함.. (전날 비염이 심해져서 잠을 제대로 못자고 7시에 겨우자서 1시간 잠\u0026hellip;. 🤧)\n원래 의왕갈 때 운전은 내가 할라그랬는데 위의 이슈로 피곤에 쩌들어서 뒷자석에서 졸면서감ㅎㅋ\n어쨋든 잘 도착해서 어머니는 동창회가 있는 장소에 떨궈주고 우리는 거기 근처 롯데 프리미엄 아울렛을 가서 아버지랑 같이 밥을 먹기로함!!\n롯데 프리미엄 아울렛 입성 보이쥬? 저어어어기에 롯데 프리미엄 아울렛이 뙇!\n본 원주 촌놈은 롯데 프리미엄 아울렛을 처음가봄\n들어서자마자 역시\u0026hellip; 아울렛은 이런 곳인가? 라는 생각을 하게됨\n오\u0026hellip;. 아니 아울렛이 뭐가 이리 좋음? 여기서 하루종일 놀아도 될 듯ㅋ\n여기는 Tasty Ground라는 곳을 가기 전에 야외에 이런 건물들이 있는데 여기 안에 들어가면 다 지하실로 이어져있고 그 지하실이 엄청 큰 푸드코트라는거\n아기들과 함께 놀러온 부부가 되게 많았고 연인사이에도 되게 많이 오신 것 같다.\n중앙 정원에는 무슨 네파(NEPA)에서 진행하는 행사? 같은게 많이 있었고 거기에 다 줄서서 행사에 참여하고 있었음. 아 이게 진정한 사람구경이지 ㅋ\n어쨋든, 우리는 밥을 먹기위해 여길 지나서 Tasty Ground라는 곳으로 향했음.\n^오^\u0026hellip; 사실 앞에 푸드코트가 더 많은데 사진을 찍질 못했다.. 구경하느라 바빠서 ㅎㅋ\n뭐먹을지 여기저기 구경하다가 아버지랑 나는 스시를 좋아하기 때문에 스시덴고쿠라는 곳에서 밥을 먹었다.\n진짜 개맛있음.. 연어두께도 두툼하고 초밥 위에 올라가있던 회들이 다 싱싱했고 식감도 뛰어났다. 내가 원주에서 먹었던 스시와는 차원이 다ㄹ\n아무튼, 아버지랑 완전 맛있다고 감탄을 하면서 먹었더니 접시는 어느새 16~17접시 정도 먹었을 듯..?\n계산대에 서니 11만 2천\u0026hellip;..음.. 뭐지 생각보다 많이 먹진 않았는데..?\n아버지 캐리로 스시를 맛있게 얻어먹고 아울렛 안에 오우야(ouya) 커피\u0026hellip;?를 갔다.\n그 옆에 젤라또도 같이 파는 것 같았는데 너무 먹고싶었지만, 우리는 상남자마냥 오우야커피에서 커피만 사들고 다시 아까 정원으로 향했다.\n하도 앉을 곳이 없어서 커피를 들고 정원쪽에서 계속 빙글빙글 돌았다.\n그냥 분수대 뒤에있던 돌담 위에 앉고 사람들도 구경하고 경치도 구경하고 따스한 햇살을 받으며 그동안 받지 못했던 광합성을 하고 있었다.\n근처 건물들 사진도 간간히 찍었다.\n사람들이 모두 여유로워보였다.. 나는 항상 바쁘게 살아야 하는 습관이 있어서 저렇게 여유롭게 즐기고 있는 사람들의 모습이 부러웠다.\n아버지한테도 이 얘기를 했다. \u0026ldquo;사람들이 되게 여유로워 보이네\u0026rdquo;\n그러자 아버지는 나에게 \u0026ldquo;물론 경제적으로 여유가 있다는 것도 중요하지만, 여유롭다는 마음가짐을 가지는 것이 먼저가 되어야 해\u0026rdquo; 라고 말해줬다.\n맞다. 항상 나는 미래의 걱정을 너무 많이 해서 지금 당장 뭐라도 하지 않으면 내 미래는 막막할거야!! 라는 생각을 가진 방식으로 생활들을 해왔다. 그래서, 어떤 무엇이든 해놓으면 미래에는 도움이 되지 않을까 해서 이것도 해보고 저것도 해보고 이거 끝나면 저거하고\u0026hellip; 걱정이 앞서서 내가 나를 바쁘게 만든 것 같다.\n아버지의 말을 듣고 나니까 오늘만큼은 그런 걱정을 잠시 내려두고 오늘의 나를 좀 더 아껴주고 즐길 때는 즐겨야겠다고 생각했다.\n근데, 아버지랑 이런저런 얘기를 하다보니 커피가 흘려져있다는 걸 알았다..\n언제 흘린거지? 생각했는데 아까 앉을 때 없어서 빙글빙글 돌았을 때 흘렸나봄\n아 ㅋㅋ 근데 발도 묻어있네 아 ㅋ\n아 근데 옷도 젖어있었음 총체적 난국이네.. 그래도 안에 입은 옷만 젖었고 겉에 옷은 안젖어서 가릴 수 있었음 ㅎㅋ 다행\n아무튼, 대화를 하던 중 어머니가 자기한테 오라고 연락이 왔다.\n그래서 우리는 곧장 어머니한테 가진않고 가기전에 아버지랑 사진 한 컷 찍기로 했다. 아버지랑 같이 찍은 사진은 생각해보니 얼마 없었던 것 같아서..\n그래서 지나가는 시민분께 촬영부탁을 드렸고 같이 찍은 사진을 얻을 수 있었다!!\n(안에 옷 흰색 쪽 보면 커피 묻어있음 😱)\n크킄 이렇게 보니 살 개쪘네.. 믿힌\n그리고 우리는 어머니가 있는 카페로 도착을 했는데, 아직 동창회가 끝나지 않았고 우리는 커피를 또 얻어먹게 된다.. (방금 전에 먹고왔는뎁..)\n어쨋든, 커피를 먹으면서 동창회 끝나는 것을 기다리고 있었다\n근데 여기 카페가 뷰가 맛집인게 앞에 백운호수가 너무 잘보였고, 오리배들이 둥둥 떠다니는게 귀여웠다.\n엌ㅋ 귀엽누\n여기 카페가 어디냐고? 안알랴줌ㅋ 알아서 찾으셈 (힌트는 흙과 나무)\n어느덧 어머니 동창회가 끝나구 다들 작별인사를 하고 갈려고 하던 중 내가 꽃가루때문에 재채기랑 콧물이 개오지게 나왔고 눈이 너무 간지러워서 눈을 하도 비벼댔더니 눈이 충혈되고\u0026hellip; 막 난리.\n근데 하필 오늘이 일요일이라 근처 약국들이 다 문을 닫은거.. 근데 롯데 아울렛에 약국이 있다더라 샹\n그래서 어머니랑 아버지랑 데리고 다시 롯데 프리미엄 아울렛으로 향했음 ㅋㅋ 아 너무 고통이여서 약을 안사고는 못베겼음\n너무 크다보니 한참을 헤메다 결국 약국을 찾았고 나는 얼른 알러지 약을 먹고 알러지 안약도 뿌렸다. 진짜 꽃가루\u0026hellip; 후.. 내가 참는다\n어머니는 아울렛을 못봤으니까 나랑 아버지가 봤던 곳을 다시 구경했다. 그리고 어머니가 빵을 먹자길래 여기를 향했다. artisan bakers 아티산 베이커스..?\n오ㅋ 빵천국\n우리는 빵을 2~3개 정도 사고, 차에 올라탔다. 어머니가 안양의 중앙시장을 가보고 싶다고 하시길래 안양까지 차를 운전해왔다. 그리고는 안양의 시내 어디엔가 차를 주차해두고 안양 중앙시장을 다녀왔다.\n음.. 그렇군\n1시간정도? 한번 둘러보고 우리는 수원에서 갈비를 먹기위해 차에서 맛집 탐색작전을 펼쳤다. 근데, 수원왕갈비 가격이 어마무시하더라..? 그래서 수원쪽으로는 못가고 대신 수원 서서갈비를 가기로함!\n경기도 용인 수지에 있는 수원 서서갈비\n들어서자마자 갈비 냄새 공격 쌉오졌고, 나도 갈비를 공격하러 왔다. 얼른 갈비를 내놓아라\n우리는 정통서서갈비 2인분이랑 순두부찌개 1개랑 비냉 1개를 시켰다.\n^오^\n아 개맛있었다.. 입에서 살살녹드라\u0026hellip;.\n그렇지\u0026hellip; 꼭 수원왕갈비가 유명하다고 거기가서 먹어야한다는 법칙은 없지. 춘천도 닭갈비가 유명하지만 사실 맛있는데가 없지 않ㄴ\n진짜 개맛있겠죠? 요즘 양이 줄어서 많이 먹지 못했다는게 가장 슬픔\n밥을 배불리 먹고 이제 원주로 돌아갈 준비 완료.\n가는데 1시간 30분 걸리더라\n나는 1시간 반동안 열심히 운전을 했고, 우리 부모님은 식곤증으로 인해 차에서 기절을 해버렸다. 오면서 약간 피곤하긴했는데 그래도 이제는 내가 운전하고 부모님을 편하게 모셔다드린다고 생각하면 뿌듯하고 기분이 좋다.\n부모님이 다른 지역을 간다고 하면 언제든지 내가 운전을 해서 갈 예정이다. (근데 3시간 이상거리는 좀ㅋㅋ)\n마무리 난 돌아와서 바로 이 글을 쓰고있고 오늘 너무 뿌듯하고 행복했던 하루였다.\n사실 의왕은 거의 올 일이 없기도 하고 원주도 잘 모르는 원주 촌놈이 다른 지역을 가서 놀 일이 있나싶다.. 어머니 동창회 덕분에 이런 지역도 가보고 하는거지!\n덕분에 가족들과 재밌는 추억도 쌓았고 또 사진을 남길 수 있어서 좋았다. 이제는 어디를 가게 된다면 꼭 사진으로 남겨놔야겠다는 생각이 들곤 한다. 우리가 나중에 웃으면서 \u0026ldquo;그때 여기 갔었지~\u0026rdquo; 할 수 있는 추억을 되돌아 볼 수 있는 기회가 있을 수도 있으니까\u0026hellip; 사진은 꼭 남겨놔야겠다.\n그리고 언제나 안전하게 귀가했다는 점에서 너무 감사하다. 사람일이 어떻게 될지 모르니까 운전하다가 운이 안좋으면 상대방으로 인해서 위협을 받을 수도 있는 상황이 발생할 수도 있는데 그런 일 없이 항상 안전하게 귀가를 할 수 있어서 참 다행이다.\n😆 어쨋든 오늘 즐거운 하루를 보냈다‼️ 😆\n4월 4째주 일요일의 일과 끝! 🙌🏻\n","date":"2023-04-23T00:00:00Z","image":"https://myeongcode.github.io/p/daily-4%EC%9B%94-4%EC%A7%B8%EC%A3%BC-sunday-%EF%B8%8F/4-4-thumb_hufe430c4728d24f04f48fefa50192b2c4_1716213_120x120_fill_q75_box_smart1.jpeg","permalink":"https://myeongcode.github.io/p/daily-4%EC%9B%94-4%EC%A7%B8%EC%A3%BC-sunday-%EF%B8%8F/","title":"[Daily] 4월 4째주 Sunday ☀️"},{"content":"Flutter 프로젝트 생성 먼저, Firebase와 연동할 Flutter프로젝트를 하나 생성해줍니다.\n프로젝트 이름은 firebase_login으로 설정해줬음\n그리고 프로젝트를 연 후 입력폼을 받을 스크린파일을 하나 만들어줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 (lib \u0026gt; screens \u0026gt; login_screen.dart) import \u0026#39;package:flutter/material.dart\u0026#39;; class LoginScreen extends StatefulWidget { const LoginScreen({super.key}); @override State\u0026lt;LoginScreen\u0026gt; createState() =\u0026gt; _LoginScreenState(); } class _LoginScreenState extends State\u0026lt;LoginScreen\u0026gt; { String userPassword = \u0026#39;\u0026#39;; String userEmail = \u0026#39;\u0026#39;; @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;LoginScreen\u0026#39;), ), body: GestureDetector( onTap: () { FocusScope.of(context).unfocus(); }, child: Center( child: Container( padding: const EdgeInsets.all(20), child: Column( children: [ TextFormField( keyboardType: TextInputType.emailAddress, key: const ValueKey(1), decoration: const InputDecoration( hintText: \u0026#39;email\u0026#39;, contentPadding: EdgeInsets.all(15), ), onSaved: (value) { userEmail = value!; }, onChanged: (value) { userEmail = value; }, ), const SizedBox( height: 20, ), TextFormField( keyboardType: TextInputType.number, key: const ValueKey(2), decoration: const InputDecoration( hintText: \u0026#39;password\u0026#39;, contentPadding: EdgeInsets.all(15), ), onSaved: (value) { userPassword = value!; }, onChanged: (value) { userPassword = value; }, ), const SizedBox( height: 20, ), Container( padding: const EdgeInsets.all(15), height: 90, width: 90, decoration: BoxDecoration( color: Colors.white, borderRadius: BorderRadius.circular(20), ), child: GestureDetector( onTap: () { print(userEmail); print(userPassword); }, child: Container( decoration: BoxDecoration( borderRadius: BorderRadius.circular(50), gradient: const LinearGradient( colors: [ Colors.orange, Colors.red, ], begin: Alignment.topLeft, end: Alignment.bottomRight, ), ), child: const Icon( Icons.arrow_forward, color: Colors.white, size: 28, ), ), ), ), ], ), ), ), ), ); } } 간단하게 입력폼으로 email과 password를 받아서 아래 버튼을 누르면 입력폼에 입력한 email과 password가 출력되게끔 만들었습니다.\n잘 나오쥬? ㅎㅎ\nFirebase 연동 Firebase페이지에 접속해서 로그인을 해줍니다.\nFirebase 프로젝트 생성 로그인을 하고나면 시작하기로 클릭하여 프로젝트 생성창으로 들어옵니다.\n위에서 프로젝트 추가를 누릅니다.\n프로젝트 이름은 가볍게 login으로 만들어주겠습니다.\n애널리틱스 사용 설정을 냅두고 다음으로 넘어갑니다.\n애널리틱스 위치를 대한민국으로 설정하고 프로젝트를 만듭니다.\n프로젝트가 다 만들어지고 계속버튼을 누르면 다음화면이 표시됩니다.\nAndroid 앱 등록 우리는 Android 기기를 연동할 것이므로 Android 아이콘표시를 누릅니다.\n그러면 위와같이 Android 앱에 Firebase 추가창이 나타납니다.\n여기서 Android 패키지 이름은 우리가 만든 Flutter 프로젝트 내의 android/app/build.gradle파일에서 확인하실 수 있습니다.\n1 2 3 4 5 6 7 8 9 (android \u0026gt; app \u0026gt; build.gradle) ... defaultConfig { ... applicationId \u0026#34;com.example.firebase_login\u0026#34; //이것이 android 패키지 이름 ... } ... com.example.firebase_login을 복사해서 android 추가하는 페이지에 붙여넣습니다.\n앱 닉네임은 정해도 좋지만, 우리는 그냥 기본값으로 쓰고 다음으로 넘어가보도록 하겠습니다.\n위처럼 나온 설명대로 google-services.json 파일을 android \u0026gt; app 폴더 내에 넣어놓고 다음을 눌러줍시다.\nandroid \u0026gt; build.gradle 파일에서 위와 같은 코드를 추가해줍니다. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 buildscript { ... repositories { google() mavenCentral() } dependencies { classpath \u0026#39;com.google.gms:google-services:4.3.15\u0026#39; ... } } allprojects { repositories { google() mavenCentral() } } android \u0026gt; app \u0026gt; build.gradle 파일에서 위와 같은 코드를 추가해줍니다. 프로젝트에서 plugin쪽은 아마 apply plugin: ~~이런 식으로 되어있을 것임 맞춰서 넣어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (android \u0026gt; app \u0026gt; build.gradle) ... apply plugin: \u0026#39;com.android.application\u0026#39; apply plugin: \u0026#39;com.google.gms.google-services\u0026#39; ... ... dependencies { implementation platform(\u0026#39;com.google.firebase:firebase-bom:31.5.0\u0026#39;) implementation \u0026#39;com.google.firebase:firebase-analytics\u0026#39; ... } 모두 코드를 추가해주었다면 다음 버튼을 눌러줍니다.\n콘솔로 이동하면 다음과 같이 안드로이드 앱이 추가된 것을 확인할 수 있습니다.\nFlutter Package 설치 Flutter에서 Firebase를 사용하기 위해서는 3가지 Package를 다운받아야 합니다.\ncloud_firestore 클라우드 호스팅되는 noSQL 데이터베이스인 Cloud Firestore용 Flutter 플러그인은 Android 및 iOS에서 라이브 동기화 및 오프라인 지원을 제공\nfirebase_core 여러 Firebase 앱에 연결할 수 있는 Firebase Core용 Flutter 플러그인\nfirebase_auth Firebase Auth용 Flutter 플러그인은 암호, 전화 번호 및 Google, Facebook 및 Twitter와 같은 ID 공급자를 사용하여 Android 및 iOS 인증을 가능하게 함\n1 2 3 4 5 6 7 8 (pubspec.yaml) dependencies: flutter: sdk: flutter cloud_firestore: ^4.5.2 firebase_core: ^2.10.0 firebase_auth: ^4.4.2 Firebase 초기화 패키지를 모두 다운받고 Flutter프로젝트로 돌아옵니다.\n우리는 firebase_core라는 패키지를 설치하였는데, 플러터에서 firebase를 사용하기에 앞서 항상 초기화해주는 메서드인 Firebase.initalizeApp() 메서드를 호출해야합니다.\n그렇지 않으면 다음과 같은 에러가 발생하게 됩니다.\n이 코드는 main.dart에 넣어주도록 하겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 (lib \u0026gt; main.dart) import \u0026#39;package:firebase_login/screens/login_screen.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:firebase_core/firebase_core.dart\u0026#39;; void main() { WidgetsFlutterBinding.ensureInitialized(); //Flutter 코어 엔진 초기화 Firebase.initializeApp(); runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( debugShowCheckedModeBanner: false, title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( primarySwatch: Colors.blue, ), home: const LoginScreen(), ); } } Firebase.initializeApp() 메서드는 비동기 방식으로 작동하는 메서드입니다. 그래서 이 메서드는 플러터와 통신을 하고싶어하지만 플러터 최상위 메서드인 runApp() 메서드가 호출되기 전에는 Flutter 엔진이 초기화 되지 않아서 접근이 불가합니다.\n메인메소드 내부에서 Flutter 엔진과 관련된 비동기 메서드를 사용하려면 먼저 Flutter 코어 엔진을 초기화시켜줘야 하는데, 이 역할을 하는 메서드가 WidgetsFlutterBinding.ensureInitialized() 입니다.\n즉, Flutter에서 Firebase를 사용하려면 main메서드 내부에서 비동기 방식으로 WidgetsFlutterBinding.ensureInitialized() 을 호출하고 난 후 Firebase.initalizeApp() 을 호출해야합니다.\n그리고 또, 비동기 방식으로 바꿔줘야하므로 다음과 같이 수정하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 (lib \u0026gt; main.dart) import \u0026#39;package:firebase_login/screens/login_screen.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:firebase_core/firebase_core.dart\u0026#39;; void main() async { WidgetsFlutterBinding.ensureInitialized(); await Firebase.initializeApp(); runApp(const MyApp()); } class MyApp extends StatelessWidget { const MyApp({super.key}); @override Widget build(BuildContext context) { return MaterialApp( debugShowCheckedModeBanner: false, title: \u0026#39;Flutter Demo\u0026#39;, theme: ThemeData( primarySwatch: Colors.blue, ), home: const LoginScreen(), ); } } Firebase instance 생성 사용자 SignUp 기능 구현 본격적으로 사용자 등록기능을 구현해보겠습니다.\n우리가 만들었던 login_screen.dart에서 firebase_auth 패키지를 import하고 instance를 생성해주겠습니다.\n한번 생성이 되면 변하지 않을 것이기 때문에 final타입으로 지정해주겠습니다. 그리고 외부에서 접근할 수 없도록 프라이빗(_)으로 만들어주겠습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (lib \u0026gt; screens \u0026gt; login_screen.dart) import \u0026#39;package:flutter/material.dart\u0026#39;; import \u0026#39;package:firebase_auth/firebase_auth.dart\u0026#39;; class LoginScreen extends StatefulWidget { const LoginScreen({super.key}); @override State\u0026lt;LoginScreen\u0026gt; createState() =\u0026gt; _LoginScreenState(); } class _LoginScreenState extends State\u0026lt;LoginScreen\u0026gt; { final _authentication = FirebaseAuth.instance; String userPassword = \u0026#39;\u0026#39;; String userEmail = \u0026#39;\u0026#39;; ... 우리는 사용자의 등록과 인증기능에 사용할 _authentication이라는 instance를 생성했습니다!\n이 인스턴스로 우리는 이메일과 패스워드를 사용한 사용자 등록 메서드.createUserWithEmailAndPassword()이나 로그인을 할 수 있도록 만들어주는 메서드.signInWithEmailAndPassword()를 사용할 수 있습니다!\n먼저 로그인기능을 만들기 전에 사용자를 등록하는 메서드를 만들어보겠습니다.\n우리는 userEmail과 userPassword로 사용자의 이메일과 패스워드를 받아올 수 있었습니다.\n그렇기때문에 다음과 같이 버튼을 눌렀을 때 해당 값이 인자로 넘어가게끔 만들어주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 (lib \u0026gt; screens \u0026gt; login_screen.dart) ... child: GestureDetector( onTap: () { _authentication.createUserWithEmailAndPassword( email: userEmail, password: userPassword, ); }, ... 예외처리를 생각한다면 다음과 같이 만들면 되겠죠?\n정상적으로 사용자 등록이 되고나면 ChatScreen() 으로 넘어가게끔 만들어줍시다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 (lib \u0026gt; screens \u0026gt; login_screen.dart) ... child: GestureDetector( onTap: () async { try { final newUser = await _authentication .createUserWithEmailAndPassword( email: userEmail, password: userPassword, ); if (newUser.user != null) { Navigator.push( context, MaterialPageRoute( builder: (context) { return const ChatScreen(); }, ), ); } } catch (e) { print(e); } }, ... 이 ChatScreen()에서 해당 사용자의 정보를 사용하려면 다음과 같이 instance를 생성해줘야합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 (lib \u0026gt; screens \u0026gt; chat_screen.dart) import \u0026#39;package:firebase_auth/firebase_auth.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; class ChatScreen extends StatefulWidget { const ChatScreen({super.key}); @override State\u0026lt;ChatScreen\u0026gt; createState() =\u0026gt; _ChatScreenState(); } class _ChatScreenState extends State\u0026lt;ChatScreen\u0026gt; { final _authentication = FirebaseAuth.instance; User? loggedUser; @override void initState() { super.initState(); getCurrentUser(); } void getCurrentUser() { try { final currentUser = _authentication.currentUser; if (currentUser != null) { loggedUser = currentUser; print(loggedUser); } } catch (e) { print(e); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;ChatScreen\u0026#39;), ), body: const Center( child: Text(\u0026#34;ChatScreen\u0026#34;), ), ); } } 이것도 마찬가지로 간단하게 예외처리를 하고 현재 로그인한 유저를 페이지가 로드되기 전에 데이터를 가져오게끔 만들기 위해 initalState()에 해당 함수를 불러오도록 하겠습니다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 (lib \u0026gt; screens \u0026gt; chat_screen.dart) import \u0026#39;package:firebase_auth/firebase_auth.dart\u0026#39;; import \u0026#39;package:flutter/material.dart\u0026#39;; class ChatScreen extends StatefulWidget { const ChatScreen({super.key}); @override State\u0026lt;ChatScreen\u0026gt; createState() =\u0026gt; _ChatScreenState(); } class _ChatScreenState extends State\u0026lt;ChatScreen\u0026gt; { final _authentication = FirebaseAuth.instance; User? loggedUser; @override void initState() { super.initState(); getCurrentUser(); } void getCurrentUser() { try { final currentUser = _authentication.currentUser; if (currentUser != null) { loggedUser = currentUser; } } catch (e) { print(e); } } @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;ChatScreen\u0026#39;), ), body: Center( child: Text( loggedUser.toString(), ), ), ); } } 그러면 이제 등록을 위한 기능은 모두 마쳤습니다!\nAVD를 다시 시작해봅시다!\n사용자 SignIn 기능 구현 로그인 기능을 하려면 다음과 같이 만들면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 (lib \u0026gt; screens \u0026gt; login_screen.dart) ... child: GestureDetector( onTap: () async { try { final newUser = await _authentication.signInWithEmailAndPassword( email: userEmail, password: userPassword, ); if (newUser.user != null) { Navigator.push( context, MaterialPageRoute( builder: (context) { return const ChatScreen(); }, ), ); } } catch (e) { print(e); } }, ... Sdk version 에러 minSdkVersion 16 cannot be smaller than version 19 declared in library\n간혹 이런 에러가 뜨게되는데 이건 아래 글에서 해결하시면 되겠습니다.\nhttps://myeongcode.github.io/p/flutter-sdk-version-%EC%98%A4%EB%A5%98/\n계정 서버 생성 우리는 유저인증에 관련된 서버를 필요로하기때문에\n왼쪽 탭에서 빌드 \u0026gt; Authentication으로 이동해줍니다.\n시작하기를 눌러줍니다.\n다양한 기능이 있는데 우리는 이메일/비밀번호 로 기능을 만들어주겠습니다.\n여기서 이메일/비밀번호의 사용설정을 체크해주고 저장을 누릅니다.\n사용설정을 마쳤습니다!!\n그리고 User탭으로 한번 가보면 아직 사용자로 등록하지 않았으니 아무것도 뜨지 않을 겁니다.\n한번 눌러볼까요?\n^오^ 성공이네요\n참고자료 https://www.youtube.com/watch?v=se6wKk-w8lI\u0026list=PLQt_pzi-LLfoOpp3b-pnnLXgYpiFEftLB\u0026index=26\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-flutter%EC%99%80-firebase-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0-android/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-flutter%EC%99%80-firebase-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0-android/","title":"[Flutter] Flutter와 Firebase 연동하기 (Android)"},{"content":"에러 내용 cloud_firestore 패키지를 설치하고 AVD를 빌드 했을 때 발생한 오류\n에러 사진 원인 flutter에서 빌드 시, 특정 라이브러리가 minsdk버전을 충족하지 못하면 아래와 같은 에러가 발생하게 됩니다.\n해결방법 android \u0026gt; app \u0026gt; build.gradle을 보면 다음과 같이 되어있다\n1 2 3 4 5 6 7 defaultConfig { applicationId \u0026#34;com.example.firebase_login\u0026#34; minSdkVersion flutter.minSdkVersion targetSdkVersion flutter.targetSdkVersion versionCode flutterVersionCode.toInteger() versionName flutterVersionName } 여기에서 minSdkVersion을 21로 변경해준다.\n1 2 3 4 5 6 7 defaultConfig { applicationId \u0026#34;com.example.firebase_login\u0026#34; minSdkVersion 21 targetSdkVersion flutter.targetSdkVersion versionCode flutterVersionCode.toInteger() versionName flutterVersionName } 참고자료 https://stackoverflow.com/questions/71495205/uses-sdkminsdkversion-16-cannot-be-smaller-than-version-19-declared-in-library\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-sdk-version-%EC%98%A4%EB%A5%98/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-sdk-version-%EC%98%A4%EB%A5%98/","title":"[Flutter] sdk version 오류"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 /* [programmers / 나머지 구하기] 입출력 예 num1\tnum2\tresult 3\t2\t1 10\t5\t0 */ function solution(num1, num2) { let answer = num1 % num2; return answer; } 아 ㅋㅋ 너무 쉽다\n완료 ✅\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%82%98%EB%A8%B8%EC%A7%80-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%82%98%EB%A8%B8%EC%A7%80-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/","title":"[Programmers] 나머지 구하기 문제"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* [programmers / 중앙값 구하기] 입출력 예 array\tresult [1, 2, 7, 10, 11]\t7 [9, -1, 0]\t0 */ function solution(array) { let sort_array = array.sort((a, b) =\u0026gt; { if (a \u0026gt; b) return 1; if (a === b) return 0; if (a \u0026lt; b) return -1; }); let half_array = parseInt(sort_array.length / 2); let answer = sort_array[half_array]; return answer; } 그냥 sort로 정렬을 하게되면 유니코드 순서에 따라서 값을 정렬하게 되므로 만약, [1, 2, 7, 10, 11]을 sort() 하게되면 [1, 10, 11, 2, 7]로 정렬이 됩니다.\n그래서 우리는 파라미터를 사용해서 a, b 두 개의 파라미터를 입력받고 a \u0026gt; b이면 1을, a === b면 0을, a \u0026gt; b이면 -1을 리턴해서 숫자 크기대로 정렬하게 해주었습니다.\n완료 ✅\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%A4%91%EC%95%99%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/","title":"[Programmers] 중앙값 구하기 문제"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* [programmers / n이하의 홀수 구하기] 입출력 예 n\tresult 10\t[1, 3, 5, 7, 9] 15\t[1, 3, 5, 7, 9, 11, 13, 15] */ function solution(n) { let oddArray = []; for (let i = 1; i \u0026lt;= n; i++) { if (i % 2 !== 0) { oddArray.push(i); } } return oddArray; } 그냥 2로 나누어 떨어지지 않는 것을 oddArray로 push시켜주었습니다.\n완료 ✅\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%A7%9D%EC%88%98%EA%B0%80-%EC%8B%AB%EC%96%B4%EC%9A%94-%EB%AC%B8%EC%A0%9C/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%A7%9D%EC%88%98%EA%B0%80-%EC%8B%AB%EC%96%B4%EC%9A%94-%EB%AC%B8%EC%A0%9C/","title":"[Programmers] 짝수가 싫어요 문제"},{"content":"문제 풀이 음\u0026hellip;. 이걸 어떻게 코드로 표현할까 고민을 많이 하던 중 그냥 어떤 식으로 하면될지 그려봤습니다.\n나는 이런 방식으로 문제를 해결해볼려고 그랬지만, 이게 완전 최적의 코드라고는 장담을 못했습니다.\n아무튼 그래서 내가 작성한 코드는 다음과 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /* [programmers / 최빈값 구하기] 입출력 예 array\tresult [1, 2, 3, 3, 3, 4]\t3 [1, 1, 2, 2]\t-1 [1]\t1 */ function solution(array) { let arrayObject = []; let maxLength = 0; let maxNum = 0; for (var i = 0; i \u0026lt; array.length; i++) { if (arrayObject.find((e) =\u0026gt; e.name === array[i])) { arrayObject.find((e) =\u0026gt; e.name === array[i]).array.push(array[i]); } else { let newObject = { name: array[i], array: [array[i]] }; arrayObject.push(newObject); } } arrayObject.map((data, index) =\u0026gt; { if (maxLength \u0026lt; data.array.length) { maxLength = data.array.length; maxNum = data.name; } else if (maxLength === data.array.length) { maxNum = -1; } }); return maxNum; } arrayObject라는 객체를 만들고 인자로 받은 array를 for문으로 돌려 만약 저 객체에 1이라는 원소가 없으면 name은 해당 원소오 하고 array로 해당 원소가 얼만큼 있는지 배열로 나타내는 새로운 객체를 생성해서 arrayObject에 push를 해줬습니다.\n그리고 1이라는 원소가 있으면 해당 객체의 array의 key값에 해당 원소를 push해줘서 배열이 쌓일 수 있도록 만들었습니다.\n그리고는 만들어진 객체에서 비교를 진행합니다. maxLength와 maxNum을 만들고 map함수를 이용해서 새로운 객체의 배열값이 더 높을때만 maxLength와 maxNum을 업데이트해주고 만약 최빈값의 개수가 같은 객체가 있다면 바로 maxNum에 -1을 넣어주었습니다.\n그 결과 다음과 같이 결과를 얻을 수 있었습니다.\n완료 ✅\n","date":"2023-04-22T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EC%B5%9C%EB%B9%88%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EC%B5%9C%EB%B9%88%EA%B0%92-%EA%B5%AC%ED%95%98%EA%B8%B0-%EB%AC%B8%EC%A0%9C/","title":"[Programmers] 최빈값 구하기 문제"},{"content":"에러 내용 Image.network로 주소에 있는 이미지를 불러오려고 했지만 다음과 같이 화면이 깨지고 이미지가 출력되지 않음\n1 2 3 4 5 6 7 8 9 10 (main.dart) ... return Column( children: [ Image.network(webtoon.thumb), Text(webtoon.title), ], ); ... 에러 사진 원인 따로 User-Agent 값을 추가하지 않으면 기본값으로 Dart/\\\u0026lt;version\u0026gt; (dart:io)가 들어갑니다.\n참고 : userAgent property\n그래서 이 값을 지우고 브라우저에서 사용하는 값으로 바꿔줍니다.\n해결방법 방법 1. headers에 useragent 추가\n1 2 3 4 5 6 ... child: Image.network( webtoon.thumb, headers: const {\u0026#34;User-Agent\u0026#34;: \u0026#34;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\u0026#34;,}, ), ... 방법 2. main.dart에서 class 추가\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class MyHttpOverrides extends HttpOverrides { @override HttpClient createHttpClient(SecurityContext? context) { return super.createHttpClient(context) ..userAgent = \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36\u0026#39;; } } void main() { HttpOverrides.global = MyHttpOverrides(); runApp(const App()); } class App extends StatelessWidget { const App({Key? key}) : super(key: key); @override Widget build(BuildContext context) { return MaterialApp( home: HomeScreen(), ); } } 참고자료 https://gist.github.com/preinpost/941efd33dff90d9f8c7a208da40c18a9\n","date":"2023-04-21T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%98%A4%EB%A5%98-1/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%98%A4%EB%A5%98-1/","title":"[Flutter] 이미지 렌더링 오류 - 1"},{"content":"에러 내용 Image.asset을 이용해서 파일 경로로 이미지를 불러왔을 때 발생한 오류\n1 2 3 4 5 6 7 8 9 (main.dart) ... Image.asset( \u0026#39;images/google-logo.png\u0026#39;, width: 70, fit: BoxFit.fill, ), ... 에러 사진 원인 pubspec.yaml에 assets를 추가해주지 않아 발생하게 된 것\n해결방법 pubspec.yaml 파일에 flutter \u0026gt; assets \u0026gt; images/ 라고 추가해줘야 이미지를 불러올 수 있게 됩니다.\n즉, 사용할 assets의 경로를 설정해줘야합니다.\n참고자료 https://security-nanglam.tistory.com/479\n","date":"2023-04-21T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%98%A4%EB%A5%98-2/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EC%98%A4%EB%A5%98-2/","title":"[Flutter] 이미지 렌더링 오류 - 2"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [baekjoon / 10699] 오늘 날짜 출력 */ var date = new Date(); let year = date.getFullYear().toString(); let month = (date.getMonth() + 1).toString(); let day = date.getDate().toString(); solution(year, month.padStart(2, \u0026#34;0\u0026#34;), day.padStart(2, \u0026#34;0\u0026#34;)); function solution(param1, param2, param3) { var today = `${param1}-${param2}-${param3}`; console.log(today); } 완료 ✅\n","date":"2023-04-20T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-10699%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-10699%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 10699번 문제"},{"content":"문제 풀이 그냥 머리로 분수 덧셈하는건 해봤는데 이 공식을 코드로 직접 적어본다고 생각하니 조금 어려웠다.. 초등학교 문제인데..\n적잖은 충격을 먹고나서 분수의 덧셈 공식을 다시 검색해봤다\n그렇다 통분을 하고 기약분수로 나타내면 되었다고 생각했다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* [programmers / 분수의 덧셈] 입출력 예 numer1 denom1\tnumer2\tdenom2\tresult 1\t2\t3\t4\t[5, 4] 9\t2\t1\t3\t[29, 6] */ function calculation(numer1, denom1, numer2, denom2) { //최대로 약분할 수 있는 숫자 let max = 1; let numer = numer1 * denom2 + numer2 * denom1; let denom = denom1 * denom2; for (let i = 1; i \u0026lt; numer; i++) { if (denom % i === 0 \u0026amp;\u0026amp; numer % i === 0) { max = i; } } return [numer / max, denom / max]; } function solution(numer1, denom1, numer2, denom2) { var answer = calculation(numer1, denom1, numer2, denom2); return answer; } 음?\u0026hellip;. 중간에 실패한 테스트 케이스가 있었다.\n한가지 알아본 테스트 중 입력이 1, 2, 1, 2가 들어가게 되면 [1, 1]로 되어야하는데 [2, 2]로까지밖에 약분이 안되어있었다.\nfor문을 다시 확인해보니 i \u0026lt;= numer까지의 범위를 해줬어야했는데 i \u0026lt; numer까지 밖에 안한 것.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* [programmers / 분수의 덧셈] 입출력 예 numer1 denom1\tnumer2\tdenom2\tresult 1\t2\t3\t4\t[5, 4] 9\t2\t1\t3\t[29, 6] */ function calculation(numer1, denom1, numer2, denom2) { //최대로 약분할 수 있는 숫자 let max = 1; let numer = numer1 * denom2 + numer2 * denom1; let denom = denom1 * denom2; for (let i = 1; i \u0026lt;= numer; i++) { if (denom % i === 0 \u0026amp;\u0026amp; numer % i === 0) { max = i; } } return [numer / max, denom / max]; } function solution(numer1, denom1, numer2, denom2) { var answer = calculation(numer1, denom1, numer2, denom2); return answer; } 완료 ✅\n","date":"2023-04-20T00:00:00Z","image":"https://myeongcode.github.io/p/programmers-%EB%B6%84%EC%88%98%EC%9D%98-%EB%8D%A7%EC%85%88-%EB%AC%B8%EC%A0%9C/program-logo_hud53099fb9da63a7d59936d9937850c96_17100_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/programmers-%EB%B6%84%EC%88%98%EC%9D%98-%EB%8D%A7%EC%85%88-%EB%AC%B8%EC%A0%9C/","title":"[Programmers] 분수의 덧셈 문제"},{"content":"문제 풀이 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* [baekjoon / 10757] 9223372036854775807 9223372036854775808 */ const fs = require(\u0026#34;fs\u0026#34;); let input = fs.readFileSync(\u0026#34;./input.txt\u0026#34;).toString(); let result = input.split(\u0026#34; \u0026#34;).filter((num) =\u0026gt; num !== \u0026#34;\u0026#34;); let num1 = parseInt(result[0]); let num2 = parseInt(result[1]); solution(num1, num2); function solution(param1, param2) { console.log(param1 + param2); } 처음엔 쉽게 정답이 될 줄 알았다..\n근데 자꾸 이상한 답이 나오더라?\n음?\u0026hellip;. 뭐야 분명 18446744073709551615이란 값이 나와야하는데 계속 18446744073709552000이 나옴\n아ㅋㅋ\n결국 한개씩 출력해봄 입력도 이상하게 나오는지\n음? ㅋㅋ 이건 또 뭐임\n찾아보니 Javascript에는 BigInt라는 새로운 데이터형이 존재한다는 것을 알았다. BigInt는 Javascript Number의 최대범위인 2^53 - 1보다 큰 정수를 표현할 수 있다고 한다.\nJavascript BigInt\n그래서 parseInt()대신 BigInt()로 바꿔서 출력해봤다.\n1 2 3 4 ... let num1 = BigInt(result[0]); let num2 = BigInt(result[1]); ... 드디어 숫자가 변하지 않고 정확하게 출력되는 것을 볼 수 있다. 근데, 뒤에 n이라는 문자가 같이 표기되어 나온다?\n이건 .toString() 메소드를 쓰면 해결되었다.\n^오^\n다시 두 수의 덧셈을 구하여 출력해보는 걸로 하고, 백준의 입력을 받을 수 있게끔 읽는 파일을 \u0026quot;/dev/stdin\u0026quot;으로 바꿔주자\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* [baekjoon / 10757] 9223372036854775807 9223372036854775808 */ const fs = require(\u0026#34;fs\u0026#34;); let input = fs.readFileSync(\u0026#34;/dev/stdin\u0026#34;).toString(); let result = input.split(\u0026#34; \u0026#34;).filter((num) =\u0026gt; num !== \u0026#34;\u0026#34;); let num1 = BigInt(result[0]); let num2 = BigInt(result[1]); solution(num1, num2); function solution(param1, param2) { let result = param1 + param2; console.log(result.toString()); } 해결완료 ✅\n","date":"2023-04-19T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-10757%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-10757%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 10757번 문제"},{"content":"Scaffold란? Flutter에서 Scaffold는 Material Design에서 사용되는 앱의 뼈대(Layout)을 제공하는 위젯입니다.\nScaffold class\n역할 Scaffold는 앱의 기본적인 레이아웃 구조를 정의하고, appbar, toolbar, drawer, tapbar 등과 같은 Material Design 구성요소를 구현합니다.\nScaffold는 일반적으로 MaterialApp위젯 내애서 사용되며, 앱의 뼈대를 제공하고, 많은 Material Design 구성요소를 간단하게 구현할 수 있기 때문에, Flutter앱을 개발할 때 매우 유용한 위젯 중 하나입니다.\nScaffold 위젯은 body속성을 통해 앱의 기본 컨텐츠를 정의하며, appBar속성을 통해 상단의 앱 바를 정의할 수 있습니다.\n또한, drawer속성을 사용하여 측면 드로어를 추가하거나 bottomNavigationBar속성을 사용하여 하단의 탭바를 추가할 수도 있습니다.\nparameter Scaffold의 parameter는 다양하지만, 우리는 가장 범용적으로 사용하는 기능에 대해 다룰 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Scaffold extends StatefulWidget { const Scaffold({ super.key, this.appBar, this.body, this.floatingActionButton, this.floatingActionButtonLocation, this.floatingActionButtonAnimator, this.persistentFooterButtons, this.persistentFooterAlignment = AlignmentDirectional.centerEnd, this.drawer, this.onDrawerChanged, this.endDrawer, this.onEndDrawerChanged, this.bottomNavigationBar, this.bottomSheet, this.backgroundColor, this.resizeToAvoidBottomInset, this.primary = true, this.drawerDragStartBehavior = DragStartBehavior.start, this.extendBody = false, this.extendBodyBehindAppBar = false, this.drawerScrimColor, this.drawerEdgeDragWidth, this.drawerEnableOpenDragGesture = true, this.endDrawerEnableOpenDragGesture = true, this.restorationId, }) Appbar Application 최상단에 위치하고 있는 bar를 말합니다. 아래와 같이 Scaffold생성자에 AppBar를 전달하면 생성할 수 있습니다.\n자세한 내용은 Appbar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), //타이틀 제목 centerTitle: true, //타이틀 가운데 정렬 (true/false) ), ); } } backgroundColor / foregroundColor 상단바의 배경색(backgroundColor) / 타이틀색(foregroundColor)를 지정할 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), backgroundColor: Colors.green, //상단바 배경색 foregroundColor: Colors.black, //상단바 타이틀색 ), ); } } elevation / shadowColor 상단바에 그림자효과를 줄 때\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), elevation: 10, //상단바 Shadow 깊이 shadowColor: Colors.red, //상단바 Shadow 색 ), ); } } leading / actions 상단바에 앞(leading)/뒤(actions)에 아이콘과 같은 위젯들을 추가하고 버튼 아이콘으로 onPressed도 실행할 수 있음\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), leading: const Icon(Icons.ac_unit), //상단바 타이틀 앞에 위젯추가 actions: [ //상단바 타이틀 뒤에 위젯추가 IconButton( icon: const Icon(Icons.photo_album), tooltip: \u0026#39;Hi!\u0026#39;, onPressed: () =\u0026gt; {}, ), IconButton( icon: const Icon(Icons.pie_chart), tooltip: \u0026#39;Wow\u0026#39;, onPressed: () =\u0026gt; {}, ) ], automaticallyImplyLeading: true, //뒤로가기 버튼 true(존재O)/false(존재X) centerTitle: true, //타이틀 가운데 정렬 ), ); } } Body Appbar의 중간영역이며, body는 하나의 Widget만 가질 수 있으며 메인 화면에 보여질 내용을 주로 작성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), body: Center( child: Column( children: const [ Text(\u0026#39;1\u0026#39;), Text(\u0026#39;2\u0026#39;), Text(\u0026#39;3\u0026#39;), Text(\u0026#39;4\u0026#39;), Text(\u0026#39;5\u0026#39;), Text(\u0026#39;6\u0026#39;), ], ), ), ); } } Bottom Navigation Bar 앱 하단에 다른 뷰를 볼 수 있도록 메뉴바를 표시해주는 위젯입니다. 보통 페이지 별 바로가기 작업을 제공하기위해 만들어집니다.\n자세한 내용은 BottonNavigationBar Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), bottomNavigationBar: BottomNavigationBar( items: const \u0026lt;BottomNavigationBarItem\u0026gt;[ BottomNavigationBarItem( icon: Icon(Icons.text_snippet), label: \u0026#39;나의 판매글\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.home), label: \u0026#39;홈\u0026#39;, ), BottomNavigationBarItem( icon: Icon(Icons.people), label: \u0026#39;마이페이지\u0026#39;, ), ], selectedItemColor: Colors.lightGreen, ), ); } } Floating Action Button 화면에 Fixed되는 원형 아이콘 버튼이며 일반적으로 화면 맨 하단 오른쪽에 위치하게 됩니다. Android 개발자들은 줄여서 FAB라고 부른다고 합니다. Icon뿐만아니라 Text로도 위젯을 사용할 수 있습니다.\n자세한 내용은 FloationActionButton Class를 확인하세요\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class HomeScreen extends StatelessWidget { const HomeScreen({super.key}); @override Widget build(BuildContext context) { return Scaffold( appBar: AppBar( title: const Text(\u0026#39;HomeScreen\u0026#39;), ), floatingActionButton: FloatingActionButton.extended( label: const Text(\u0026#39;Approve\u0026#39;), icon: const Icon(Icons.thumb_up), backgroundColor: Colors.pink, onPressed: () =\u0026gt; {print(\u0026#39;hello\u0026#39;)}, ), ); } } ","date":"2023-04-18T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-scaffold-widget/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-scaffold-widget/","title":"[Flutter] Scaffold Widget"},{"content":"Dart란? Dart는 구글이 디자인한 멀티 플랫폼 프로그래밍언어입니다.\n자바스크립트를 대체할 수 있는 크로스 플랫폼 프로그래밍 언어를 목표로 설계했다고 합니다.\nDart는 Flutter에서 사용되는 언어이며 모든 플랫폼에서 빠른 앱을 위한 클라이언트 최적화 언어입니다.\nUI 최적화용 : 사용자 인터페이스 생성 요구에 특화된 프로그래밍 언어로 개발\n생산적인 개발 : 핫 리로드를 사용하여 실행 중인 앱에서 즉시 결과 확인\n모든 플랫폼에서 빠름 : 모바일, 데스크톱 및 백엔드용 ARM 및 x64 머신 코드로 컴파일합니다. 또는 웹용 JavaScript로 컴파일\nDart 공식 사이트\n사이트에 본 설명에 의하면 Dart는 두 개의 컴파일러를 가지고 있다.\nDart Web : Dart로 쓴 코드를 javascript로 변환해주는 컴파일러 Dart Native : Dart로 쓴 코드를 여러 CPU의 아키텍쳐에 맞게 변환해주는 컴파일러 (ARM32, 모바일인 ARM64(IOS, Android), 데스크탑인 x86_64(Mac, Linux, Windows) 등등에 맞게 변환해준다는 의미) JIT, AOT Dart는 또 어떻게 컴파일 되는지에 대해 JIT, AOT로 볼 수 있다.\nJIT(Just-In-Time) : 개발 중에는 수정된 코드가 결과로 바로 나타날 수 있게끔 만드는 컴파일러로 Dart VM(Virtual Machine)을 사용하여 Just-In-Time 컴파일러를 제공합니다. AOT(Ahead-of-time) : 배포를 할 때에는 더이상 Dart VM(Virtual Machine)을 사용하지 않고 Ahead-Of-Time 컴파일러를 제공하여 각 아키텍쳐에 맞는 기계어로 컴파일이 되고 앱을 더 빠르게 실행시킬 수 있게 만듭니다. 이러한 특징을 갖는 것은 모바일 개발에 있어서 아주 중요하고 멋진 특징입니다. 개발 중에 바로바로 피드백을 확인할 수 있고, 앱을 배포할 때에는 휴대폰, 노트북, 웹사이트에서 기계어를 실행하여 편하게 배포를 할 수 있습니다.\nnull safety 다른 언어에서는 코드에서 null 값을 참조해버리면 오류가 발생하여 더 이상 동작을 할 수 없게 만들지만, Dart는 이러한 문제를 방지하기 위해 null safety라는 것을 도입했습니다.\n결론 Flutter는 Dart라는 언어를 사용하는데 둘 다 구글에서 제작한 것이므로 Dart는 Flutter를 위한 언어라고 볼 수 있습니다. 그래서 Flutter에서의 Dart언어를 최적화하고싶다면 수정을 할 수 있다는 큰 장점이 있습니다.\n이것이 중요한 이유는 React나 Vue는 언어에 대해 최적화를 하고싶다고 하여도 javascript를 수정할 수 없습니다. 다른 언어들도 마찬가지입니다. 그렇기때문에 이 점은 매우 강한 장점으로 보이며 그 속에 또 다른 단점이 존재할 수 있습니다. 하지만, RN에 비해 Flutter의 사용비율이 급격히 증가해지면서 커뮤니티가 활성화되고있고 더 많은 기능을 기대할 수 있을 것 같습니다.\nFlutter에 관심이 많다면 한번 배워보는 것도 좋을 것 같습니다.\n","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/dart-logo_hu6ca51b6ea6e3939baa7b81d018f1cfc2_224667_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/dart-flutter%EC%97%90%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-dart%EC%96%B8%EC%96%B4%EB%9E%80/","title":"[Dart] Flutter에서 사용하는 Dart언어란?"},{"content":"Flutter란? Flutter는 Google에서 개발한 크로스 플랫폼 모바일 앱 개발 프레임워크\n크로스 플랫폼 모바일 앱 개발 프레임워크란?\niOS나 Android 두 OS에 대해 하나의 코드베이스로 관리하여 여러 플랫폼에 동시에 서비스를 제공하기 위한 프레임워크\nNative vs Cross Platform vs Hybrid 앱 서비스 개발시 3가지 방법으로 서비스를 제공할 수 있습니다.\n네이티브 앱 크로스 플랫폼 프레임워크 하이브리드 앱 네이티브 앱 네이티브 앱은 플랫폼의 네이티브 언어와 프레임워크를 이용해 개발하며 기기에 맞게 어플리케이션을 개발할 수 있지만, 여러 플랫폼에서 제공하기 위해서는 각각 개발을 할 수 있어야함\n크로스 플랫폼 프레임워크 크로스 플랫폼 프레임워크는 하나의 코드베이스로 여러 플랫폼을 관리 및 서비스할 수 있으며 자바스크립트, C#, Dart를 안다면 개발을 시작할 수 있음\n하이브리드 앱 하이브리드 앱은 웹페이지를 웹뷰로 감싸서 플랫폼처럼 서비스를 제공할 수 있으며 웹개발로 앱도 동시에 개발할 수 있고, 앱과 같은 경험을 만들어 줄 수 있음\n자세한 내용은 추후에 더 포스팅을 하여 각 방법의 특장점을 살펴보도록 하겠습니다.\n그렇다면 왜 Flutter는 CrossPlatform을 사용할까요? 모바일의 경우 iOS와 Android 개발자가 각각 있다면 CrossPlatform으로 개발하지 않아도 됩니다. 하지만, 각 OS별로 유저들에게 동일한 UI/UX를 제공하면서 개발하는 것은 결코 쉬운일이 아닙니다. 또, 각 OS별로 개발자가 필요하다보니 개발자원이 2배 이상 필요하게 됩니다. 그리고, 한명의 개발자가 두 OS 모두 개발한다고 하더라도 각 OS의 개발방식이 서로 다르기때문에 시간도 많이 소요됩니다.\n개발을 완료했다쳐도 각 OS마다 앱의 유지보수가 쉽지 않다는 단점이 있습니다.\n그래서 크로스 플랫폼을 사용한다면 개발 자원과 시간을 줄일 수 있으며, 하나의 프레임워크로 Android, iOS 둘 다 동시에 개발이 가능해집니다. 유지보수 측면에서도 하나의 코드베이스로 되어있다보니 훨씬 편리하게됩니다.\n기존의 앱 시장에서는 React Native가 시장을 장악하고 있었지만, Flutter가 나온 후로 많은 개발자들이 유입되었고 커뮤니티또한 활발하게 성장하고 있습니다.\n2023년 2월 기준으로 Stack Overflow Survey 2022에서 나온 결과를 보면 Flutter가 간소한 차이로 우위를 하고 있는 것을 볼 수 있습니다.\nThe results of the annual Stack Overflow Survey 2022\n또 아래에는 React Native와 Flutter의 비교영상입니다.\nhttps://www.youtube.com/watch?v=BqGxJ_ybE6k\nFlutter는 어떤 언어를 사용하나요? Flutter는 Dart라는 언어를 사용합니다. 이 Dart언어 또한 구글에서 개발한 언어입니다.\n기존의 앱 개발자들에게는 또 다시 언어를 배워야한다는 단점이 있지만, 문법자체가 그렇게 어렵진 않은 것 같아 어느정도 개발을 하셨던 분들이라면 빠르게 적응하실 수 있을 것입니다.\nDart에 대하여 더 궁금한 내용은 Flutter에서 사용하는 Dart언어란?을 봐주세요.\nFlutter의 특징 장점\n통합 개발 환경지원\nFlutter는 다양한 Editor(Android Studio, VS Code 등등)를 사용하여 빌드가 가능합니다. Android Studio는 Flutter Inspector와 Flutter Outline이라는 개발 도구를 추가적으로 지원해줍니다. VS code 에서는 간단하게 Extension 으로 Flutter를 설치하여 Flutter를 사용할 수 있습니다.\n성능 문제해결\n기존 React Native 혹은 Hybrid App의 경우 네이티브 브릿지를 통한 통신이 불가피했습니다.\n하지만 Flutter는 직접 컴파일되서 Render를 직접 하기때문에 성능이 빠릅니다. 애니메이션 속도가 60프레임은 가뿐히 넘어서는 것이 기존 크로스 플랫폼시장의 주류였던 React Native와 Flutter를 비교하는 많은 글들에서 Flutter를 내세우는 부분입니다.\nMateiral Design \u0026amp; Cupertino\nFlutter는 Androd와 iOS의 대표 디자인 가이드를 기본적으로 제공합니다. 구글의 머티리얼 디자인(Material Design)의 홈페이지에는 이미 Flutter가 포함되어 있고 가이드만 제공하는 것 뿐만아니라 Flutter 프로젝트에 바로 추가하여 사용할 수 있는 패키지도 제공합니다.\n안드로이드와 iOS에서 같은 머티리얼 디자인을 사용하더라도 플랫폼에 따라 다르게 출력되는 부분을 각각 디자인 가이드에 맞게 화면을 그립니다. iOS앱을 개발하는 경우 iOS특유의 디자인 시스템인 쿠퍼티노(Cupertino) 위젯을 제공합니다.\n그렇기에 선택의 폭이 정해져 있기 때문에 어떤 UI 라이브러리를 사용할 것인지 고민 할 필요가 없습니다만 이건 장점이자 단점이 될수도 있습니다.\nDart뿐만 아니라 Native코드도 사용\n앞서 Dart를 사용한다고 했지만 결국엔 크로스 플랫폼이기에 해당 OS에 최적화된 앱을 만들려면 Native 코드를 사용할수밖에 없고 Dart와 섞어서 사용을 합니다. 즉, Dart만 사용하는것이 아니라 Android면 Kotlin, iOS면 Swift도 사용합니다. 이는 기존의 Native 코드를 사용한 개발자라면 장점이 됩니다.\n단점\nNative API를 Dart에서 직접 호출 불가\n특별히 심하게 문제가 되진 않지만 외부 플러그인을 써야합니다.\n코드를 고치려면 새 버전을 배포\nReact Native, Cordova, Ionic 에선 이미 지원 중 입니다.\nhttps://github.com/flutter/flutter/issues/14330\nAir bnb Lotti 지원 X\nFlutter는 지원하지 않습니다. Android, iOS, React-Native만 지원\nLotti는 어플리케이션에 Fancy한 애니메이션을 넣어주는 라이브러리입니다.\nhttps://airbnb.design/lottie/\nWearable 디바이스앱에 약함\n플러그인이 존재는 하지만 Native처럼 쉽게 되지는 않습니다.\nC/C++ 라이브러리 호출 불가\nNDK C/C++ 라이브러리 호출이 Dart에서 안됩니다. 외부 플러그인을 써야하고, 원하는 플러그인이 없다면 만들어야 하는데 이는 보통일이 아닙니다.\n지원되는 플러그인이 부족\n아직 플러그인들은 부족한 편입니다. 어플을 생성할 때, Webview, Map 등 플러그인은 필요합니다.\n하지만 Flutter의 이러한 플러그인들은 전부 0.4, 0.3 등등 1.0을 넘는 버전을 보기가 힘듭니다. 따라서 지속적으로 업데이트가 되고있고, 업데이트가 될때마다 다시 붙이고 테스트해보는 것은 어마어마하게 번거로운 일이 될 것입니다.\n아직까진 국내에 개발관련 자료가 많이 없음\nndroid, iOS Native는 나온지 오래되서 자료가 많다보니 문제해결이 쉽습니다만, 국내엔 아직까진 자료가 많다고 할수가 없어 이슈 상황 발생시 자료 찾기가 어렵습니다.\n또한, Flutter 개발자들도 그렇게 많은 편이 아니기에 도움을 구하기도 어느정도 힘이 듭니다.\n결론 점점 성장 중이며 React Native보다 사용을 많이한다고는 하지만, 아직 플러그인이 부족한 것은 사실이며 소규모로 빠르게 시작하기 위해서는 Flutter를 사용하는게 맞겠지만, 어느정도 규모가 있다면 각각의 OS에 맞는 전문 개발자를 뽑아서 개발하는 것이 질적으로 더 가치가 있을 것 같습니다.\n아직 국내에 많은 레퍼런스가 없긴 하지만 학생으로서 Flutter로 빠르게 서비스를 제공하는 경험을 해보는 것도 괜찮을 것 같습니다. 기본적으로 괜찮은 기능들이 많고 React Native에서 힘들게 작업해야 하는 것을 Flutter에서는 손쉽게 구현하는 것도 코린이로서 이점이 될 수도 있습니다.\nFlutter도 외국에 생각보다 많은 서비스를 하고있으며 지속적으로 업데이트되고 더 안정화가 된다면 강력한 프레임워크가 되지 않을까 생각합니다.\n참고자료 https://blog.mayleaf.dev/24\nhttps://velog.io/@jojo_devstory/Flutter%EB%9E%80-Flutter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90#4-flutter%EC%9D%98-%ED%8A%B9%EC%A7%95\n","date":"2023-04-17T00:00:00Z","image":"https://myeongcode.github.io/p/flutter-flutter%EB%9E%80-flutter%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/flutter-logo_hud4db78cc4099f0118a23ad8c4eb3c315_171298_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/flutter-flutter%EB%9E%80-flutter%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%BC%EA%B9%8C/","title":"[Flutter] Flutter란? Flutter가 무엇일까?"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2023-04-16T00:00:00Z","image":"https://myeongcode.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hud7e36f7e20e71be184458283bdae4646_55974_120x120_fill_q75_box_smart1.jpg","permalink":"https://myeongcode.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"반가워요! 앞으로 다시 포스팅 열심히하기 ✍🏻\n","date":"2023-04-16T00:00:00Z","permalink":"https://myeongcode.github.io/p/%ED%99%88%ED%8E%98%EC%9D%B4%EC%A7%80-%EC%83%88-%EB%8B%A8%EC%9E%A5/","title":"홈페이지 새 단장"},{"content":"문제 풀이 (처음 생각한 답)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { float a, b, result; scanf(\u0026#34;%f %f\u0026#34;, \u0026amp;a, \u0026amp;b); result = a / b; printf(\u0026#34;%.10f\u0026#34;, result); return 0; } 하지만, 위의 문제에서 출력부분을 보면 ‘실제 정답과 출력값의 절대오차 또는 상대오차가 $10^{-9}$이하이면 정답’ 이라고 표시되어 있다.\n이게 무슨말이냐?\n먼저 float으로 받아서 float으로 출력을 해보면 다음과 같이 나옵니다.\n실제 답은 0.333333333333…이 나와야하는데 0.3333333433이 출력이 됩니다.\n그러면 실제 답과의 절대오차는 0.0000000100…이 됩니다.\n절대오차가 1 * 10^{-8}만큼 차이나므로 10^{-9}이하가 아니게 됩니다\n1 * 10^{-8} \u0026gt; 10^{-9}\n그러면 상대오차로 계산해보겠습니다.\n상대오차는 배율로 생각하면 편합니다. 원래 답과의 차이가 +-10까지 허용한다 그러면 상대오차는 10^{-1}까지 허용하는 셈입니다. +-1까지 허용한다하면 10^{-2}까지 허용하는겁니다.\n그렇다면, 0.3333333333과 0.3333333433의 상대오차는 어떻게 될까요\n공식을 이용하면\n상대오차 = {1*10^{-8}}{0.3333333333} * 100 = 0.000003\n배율만큼 차이가 난다는 의미입니다. 그러므로 상대오차 또한 10^{-9}보다 크므로 상대오차도 오답이 되는 것입니다.\n그러면 어떻게 해야하냐면 정밀도가 더 큰 자료형으로 바꾸면 됩니다.\nfloat보다는 double의 정밀도가 더 큽니다.\nfloat과 double의 범위또한 다르며 유효자릿수가 double이 더 크기때문에 더 정밀하다는 의미가 됩니다.\n따라서, 백준에서는 더 정밀한 값을 정답으로 처리하겠다는 것입니다.\n그럼 자료형을 float이 아닌 double로 바꿔서 출력해보겠습니다\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define _CRT_SECURE_NO_WARNINGS #include \u0026lt;stdio.h\u0026gt; int main(void) { double a, b, result; printf(\u0026#34;-------input-------\\n\u0026#34;); scanf(\u0026#34;%lf %lf\u0026#34;, \u0026amp;a, \u0026amp;b); printf(\u0026#34;\\n\u0026#34;); result = a / b; printf(\u0026#34;-------output-------\\n\u0026#34;); printf(\u0026#34;%.10lf\\n\u0026#34;, result); return 0; } ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1008%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1008번 문제"},{"content":"문제 풀이 이 문제는 C언어로 풀어봤지만, C언어에서 정수형의 표현 범위는 long을 이용해도 2,147,483,647정도로 10의 1000승에 비하면 터무니없이 작은 수이기 때문에 계산할 수 있는 범위를 벗어나서 오버플로우가 발생했고, 출력값이 잘못 나오게 되는겁니다.\n따라서, 이 문제는 C가 아닌 파이썬을 이용하면 훨씬 더 쉽게 풀 수 있다는 것을 알았습니다.\n왜냐하면 파이썬은 큰 수를 자동으로 처리해주기 때문이죠.\n1 2 3 4 m, n = map(int, input().split()) print(m // n) print(m % n) ","date":"2022-10-26T00:00:00Z","image":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/baekjoon_hu42505e151a7615c4e98d9937cdff0e57_83678_120x120_fill_box_smart1_3.png","permalink":"https://myeongcode.github.io/p/baekjoon-1271%EB%B2%88-%EB%AC%B8%EC%A0%9C/","title":"[Baekjoon] 1271번 문제"}]